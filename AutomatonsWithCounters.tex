\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{fontspec}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{nccthm}
\usepackage{indentfirst}

\setmainfont{Liberation Serif}

\ProofStyleParameters{\bfseries}{Доказательство}
\newtheorem{definition}{Определение}
\newtheorem{theorem}{Теорема}
\newtheorem{note}{Замечание}
\newtheorem{lemma}{Лемма}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\F}{\mathcal{F}}

\title{Автоматы со счётчиком}
\author{Илхомов Мухаммад}
\date{}

\begin{document}

\maketitle

\clearpage

\tableofcontents

\clearpage

\section{Введение}

\section{Основные определение и понятия}

Обозначим множества натуральных чисел через \(\N\). Положим \(\N_0 = N \cup
\{0\}\).

Определения автомата совпадает с определением приведенное в
\cite{litautomatatheory}.

В этой работе определение автомата будет такой:

\begin{definition}
  \label{def:automata}
  Автомат с \(n\) счётчиками называется семёрка
  \(\A = (A, Q, Q_f, B, \varphi, \bar{\psi}, q_0)\), где:
  \begin{itemize}
    \item \(A=\{0, 1\}^n\) --- входной алфавит
    \item \(Q\) --- множество состояний
    \item \(Q_f\) --- множество финальных состояний
    \item \(B=\{-1, 0, 1\}^n\) --- выходной алфавит
    \item \(\varphi: (Q \setminus Q_f) \times A \rightarrow Q\) ---
      функция переходов
    \item \(\bar{\psi}: (Q \setminus Q_f) \times A \rightarrow B\) ---
      функция выхода, которая состоит из \(n\) функции: \linebreak
      \(\bar{\psi} = (\psi_1, \psi_2, \ldots, \psi_n)\).
  \end{itemize}

  При этом есть ограничения для \(\bar{\psi}\):

  \begin{equation}
    \label{eq:constraint}
    \forall i \in \{1, 2, \ldots, n\}\ (x_i = 0 \Rightarrow
    \psi_i(q, x_1, x_2, \ldots, x_i, \ldots, x_n) \geq 0)
  \end{equation}
\end{definition}

\begin{definition}
  \label{def:initialized_automata}
  Упарядоченного множество \((\A, z_1^0, z_2^0, \ldots, z_n^0)\)
  называется инициализированный автомат с \(n\) счётчиками, где
  \begin{itemize}
  \item \(\A\) --- автомат с \(n\) счётчиками
  \item \(z_i^0 \in \N_0\) --- начальным значениям \(i\)-го счётчика, где
    \(i \in \{1, 2, \ldots, n\}\)
  \end{itemize}
\end{definition}

\begin{definition}
  \label{def:canonical}
  Пусть у нас есть инициализированный автомат с \(n\) счётчиками
  \((\A, z_1^0, z_2^0, \ldots, z_n^0)\).
  Каноническими уравнениями называется система \ref{eq:canonical}
  \begin{equation}
    \label{eq:canonical}
    \begin{cases}
      q(0) = q_0 \\
      z_1(0) = z_1^0 \\
      z_2(0) = z_2^0 \\
      \ldots \\
      z_n(0) = z_n^0 \\
      q(t + 1) = \varphi(q(t), a(t)) \\
      z_1(t + 1) = z_1(t) + \psi_1(q(t), a(t)) \\
      z_2(t + 1) = z_2(t) + \psi_2(q(t), a(t)) \\
      \ldots \\
      z_n(t + 1) = z_n(t) + \psi_n(q(t), a(t))
    \end{cases}
    \end{equation}
    где
    \begin{align*}
      & t \in \N_0 \\
      & a(t) = (\text{sign}(z_1(t)), \text{sign}(z_2(t)), \ldots,
      \text{sign}(z_n(t))) \\
      & \text{sign}(x) =
      \begin{cases}
        -1, &x \in (-\infty; 0) \\
        0, &x = 0 \\
        1, &x \in (0; \infty)
      \end{cases} \\
    \end{align*}
\end{definition}

\begin{definition}
  \label{def:behaviour}
  Пусть у нас есть автомат с \(n\) счётчиками
  \((\A, z_1^0, z_2^0, \ldots, z_n^0)\).
  \begin{itemize}
    \item Если существуеть момент времени \(t'\), такое что \(q(t') \in Q_f\),
      тогда поведением инициализированного автомата с \(n\) счётчиками
      называется конечная последовательность:
      \begin{align*}
        & (q(0), z_1(0), z_2(0), \ldots, z_n(0)) \\
        & (q(1), z_1(1), z_2(1), \ldots, z_n(1)) \\
        & \ldots, \\
        & (q(t'), z_1(t'), z_2(t'), \ldots, z_n(t'))
      \end{align*}
      В этом случае говорится инициализированный автомат с \(n\) счётчиками
      остановится.
    \item Если не существуеть момент времени \(t'\), такое что \(q(t') \in Q_f\),
      тогда поведением инициализированного автомата с \(n\) счётчиками
      называется бесконечная последовательность:
      \begin{align*}
        & (q(0), z_1(0), z_2(0), \ldots, z_n(0)) \\
        & (q(1), z_1(1), z_2(1), \ldots, z_n(1)) \\
        & \ldots, \\
        & (q(t), z_1(t), z_2(t), \ldots, z_n(t')) \\
        & \ldots
      \end{align*}
      В этом случае говорится инициализированный автомат с \(n\) счётчиками
      не остановится.
  \end{itemize}
\end{definition}

Автомат с \(n\) счётчиками можно рассмотреть как автомат соединенные с
\(n\) внешными памятам, каждый который можеть хранить неотрицательное число.
Автомат может видить только то что, каждый счётчик равно нулью или нет.
Каждый момент времени автомат может менять значения счётчика не болле чем на
одну единицу, при этом значения счётчиков всегда дожен остаться неотрицательным.
Ограничение \ref{eq:constraint} как раз таки обеспечиваеть неотрицательность
счётчиков.

Рассмотрим автомат с двумя счётчиками.

\begin{definition}
  \label{def:manoeuvre}
  Пусть у нас есть инициализированный автомат с двумя счётчиками.
  Конечным маневрем называется поведение автомата от момента времени \(t_1\)
  до \(t_2\):
  \begin{align*}
    & (q(t_1), z_1(t_1), z_2(t_1)), \\
    & (q(t_1 + 1), z_1(t_1 + 1), z_2(t_1 + 1)), \\
    & \ldots, \\
    & (q(t_2), z_1(t_2), z_2(t_2))
  \end{align*}
  если выполняется один из следущих условий:
  \begin{align*}
    & \begin{cases}
      z_1(t_1) = 0 \\
      \forall t (t_1 < t < t_2 \Rightarrow z_2(t) \neq 0) \\
      z_2(t_2) = 0
    \end{cases}
    \begin{cases}
      z_2(t_1) = 0 \\
      \forall t (t_1 < t < t_2 \Rightarrow z_1(t) \neq 0) \\
      z_1(t_2) = 0
    \end{cases} \\
    & \begin{cases}
      z_1(t_1) = 0 \\
      \forall t (t_1 < t < t_2 \Rightarrow z_2(t) \neq 0) \\
      q(t_2) \in Q_f
    \end{cases}
    \begin{cases}
      z_2(t_1) = 0 \\
      \forall t (t_1 < t < t_2 \Rightarrow z_1(t) \neq 0) \\
      q(t_2) \in Q_f
    \end{cases}
  \end{align*}
\end{definition}

\begin{definition}
  \label{def:infinity_manoeuvre}
  Пусть у нас есть инициализированный автомат с двумя счётчиками.
  Бесконечным маневрем называется поведение автомата от момента времени \(t_1\):
  \begin{align*}
    & (q(t_1), z_1(t_1), z_2(t_1)), \\
    & (q(t_1 + 1), z_1(t_1 + 1), z_2(t_1 + 1)), \\
    & \ldots
  \end{align*}
  если выполняется один из следущих условий:
  \begin{align*}
    \begin{cases}
      z_1(t_1) = 0 \\
      \forall t (t_1 < t \Rightarrow (z_2(t) \neq 0 \wedge q(t) \notin Q_f) \\
    \end{cases}
    \begin{cases}
      z_2(t_1) = 0 \\
      \forall t (t_1 < t \Rightarrow (z_1(t) \neq 0 \wedge q(t) \notin Q_f) \\
    \end{cases}
  \end{align*}
\end{definition}

Мы рассмотрим вычислимость частично определенных функции из \(m\)
переменных, то есть функции, которые имеет вид:
\({f: M \rightarrow \N_0 \cup \{\lambda\}}\), где \(M \subseteq \N_0^m\).
Будем записать \(f(x_1, \ldots, x_m) = \lambda\),
если \(f\) в точке \((x_1, \ldots, x_m)\) неопределено.

\begin{definition}
  \label{def:computability}
  Будем говорить что автомат \(\A\) с \(n\) счётчиками вычисляет функция
  \(m\)-переменных \(f_{\A}: \N^m_0 \rightarrow \N_0\) (где \(m \leq n\)), если:
  \begin{itemize}
    \item \(f_{\A}(x_1, x_2, \ldots, x_m) = y\) и инициализированный автомат
      \((\A, x_1, x_2, \ldots, x_m, 0, \ldots, 0)\) остановится,
      причем в момент остановки \(t'\) значения одного счётчика равно \(y\),
      а всех остальных равен \(0\)
    \item \(f_{\A}(x_1, x_2, \ldots, x_m) = \lambda\) и инициализированный
      автомат с \(n\) счётчиками
      \((\A, x_1, x_2, \ldots, x_m, 0, \ldots, 0)\) остановится,
      причем в момент остановки \(t'\) существует ненулевой счётчик кроме
      первого счётчика
    \item \(f_{\A}(x_1, x_2, \ldots, x_m) = \lambda\) и инициализированный
      автомат с \(n\) счётчиками
      \((\A, x_1, x_2, \ldots, x_m, 0, \ldots, 0)\) не остановится
  \end{itemize}
\end{definition}

Мы рассморим только частично определенных функции одной переменной.
Обозначим через \(J_n\) множество всех частично определенных функции одной
переменной, которые вычислимы через автоматы с \(n\) счётчиками.
Очевидно что для любого \(n\) верно \(J_n \subseteq J_{n + 1}\).

Обозначим через \(\F\) все частично определенных функции одной
переменной.

Множество значений функции \(f \in \F\) обозначим через \(Im(f)\).

\begin{definition}
  \label{def:switcher}
  Пусть \(\varphi \in \F\).
  \(\varphi\) называется переключательной функцией, если
  \(Im(\varphi) < \infty\).
\end{definition}

Обозначим через \(\Phi\) множество всех переключательных функции.

\begin{definition}
  \label{def:switcher_rang}
  Пусть \(\varphi \in \Phi\).
  \(Im(\varphi)\) называется рангом функции \(\varphi\).
\end{definition}

\begin{definition}
  \label{def:function_with_switcher}
  Пару \((f, \varphi)\) называется функцию с переключателем,
  если \(f \in \F, \varphi \in \Phi\) и
  \(\forall x [f(x) = \lambda \Leftrightarrow \varphi(x) = \lambda]\).
  \(f\) называется основной функцией.
\end{definition}

\begin{definition}
  \label{def:generalized_superposition}
  Пусть \(n \in \N\),
  \((f_0, \varphi_0)\), \((f_1, \varphi_1)\), \((f_2, \varphi_2)\), \ldots,
  \((f_n, \varphi_n)\) --- функции с переключателями и
  \(E(\varphi_0) = \{k_1, k_2, \ldots, k_n\}\).
  Тогда определим оператор обобщенной суперпозиции \(S_n\) следующим образом:
  если \((f, \varphi) = S_n[(f_0, \varphi_0), (f_1, \varphi_1), (f_2, \varphi_2),
  \ldots (f_n, \varphi_n)]\), то \(f\) и \(\varphi\) имеет вид
  \begin{align}
    \label{eq:generalized_superposition}
    & f(x) =
      \begin{cases}
        f_1(f_0(x)), & \varphi_0(x) = k_1 \\
        f_2(f_0(x)), & \varphi_0(x) = k_2 \\
        \ldots \\
        f_n(f_0(x)), & \varphi_0(x) = k_n
      \end{cases} \\
    & \varphi(x) =
      \begin{cases}
        \varphi_1(f_0(x)), & \varphi_0(x) = k_1 \\
        \varphi_2(f_0(x)), & \varphi_0(x) = k_2 \\
        \ldots \\
        \varphi_n(f_0(x)), & \varphi_0(x) = k_n
      \end{cases}
  \end{align}
  При этом для любого \(x \in \N_0\) если \(f_0(x) = \lambda\) (соответственно
  \(\varphi_0(x) = \lambda\)), то \(f(x) = \lambda\) и \(\varphi(x) = \lambda\)
\end{definition}

Прежде чем определять следующий оператор введем некоторые обозначения:
\begin{itemize}
\item
  \(f^k(x)\) --- это \(k\) раз применения функция \(f\) на \(x \in \N_0\).
  Если для \(x\) существуеть \(l \in \overline{1, k}\), такая что
  \(f^l(x) = \lambda\), то \(f^k(x) = \lambda\).
\item
  Пусть \((f, \varphi)\) --- функция с переключателелем.
  Тогда для любого \(a \in \N_0\) определим следующие множества:
  \begin{align*}
    & \Delta_0(a) = \{x \in \N_0 | \varphi(x) = a\} \\
    & \Delta_{k + 1}(a) = \{x \in \Delta_{k} | \varphi(f^{k + 1}(x)) = a\},\ \text{где}\ k \geq 0 \\
    & X_0(a) = \N_0 \setminus \Delta_0(a) \\
    & X_{k + 1}(a) = \Delta_{k}(a) \setminus \Delta_{k + 1}(a),\ \text{где}\ k \geq 0 \\
    & X_{\infty}(a) = \N_0 \setminus \bigcup_{k \geq 0} X_k(a)
  \end{align*}
\end{itemize}

\begin{definition}
  \label{def:special_recursion}
  Пусть \((f_0, \varphi_0)\) --- функция с переключателем
  Тогда определим оператор специальной рекурсии \(R\) следующим образом:
  Если \((f, \varphi) = R[f_0, \varphi_0]\), то \(f\) и \(\varphi_0\) имеет вид:
  \begin{align}
    \label{eq:generalized_superposition}
    & f(x) =
      \begin{cases}
        f^{k + 1}_0(x), & x \in X_k(a) \\
        \lambda, & x \in X_{\infty}(a)
      \end{cases} \\
    & \varphi(x) =
      \begin{cases}
        \varphi_0(x), & x \in X_0(a) \\
        \varphi_0(f_0^k(x)), & x \in X_k(a), k \geq 1 \\
        \lambda, & x \in X_{\infty}(a)
      \end{cases}
  \end{align}
  При этом для любого \(x \in \N_0\) если \(f_0^l(x) = \lambda\) (где \(1 \geq l \geq k\)),
  то \(f(x) = \lambda\) и \(\varphi(x) = \lambda\)
\end{definition}

\begin{definition}
  \label{def:periodic}
  Функцию \(f \in \F\) называется периодичным, если существуеть
  \(T \in \N\) и \(x_0 \in \N_0\), такое что для любого \(x > x_0\) и для любого
  \(k \in \N_0\) верно \(f(x) = f(x + kT)\).
\end{definition}

Обозначим минимальный период функции \(\varphi\) через \(T_{\varphi}\).

Обозначим множество всех перидочных функции через \(\Phi_p\).
Очевидно что \(\Phi_p \subset \Phi\)

\begin{definition}
  \label{def:pseudoperiodic}
  Функцию \(f \in \F\) называется псевдопериодичным, если
  существуеть \(T_0 \in \N_0\), такое что для любого \(x > T_0\) существует
  \(T \in \N\), такое что для любого \(k \in \N_0\) верно \(f(x) = f(x + kT)\).
\end{definition}

Обозначим множество всех псевдоперидочных функции через \(\F_p\).
Очевидно что \(\Phi_p \subset \F_p\).

\begin{definition}
  \label{def:manoeuvre_function}
  Функцию \(f \in  \F\) называется функцию маневра если она имеет один из
  следующих видов:
  \begin{align}
    \label{eq:manoeuvre_function}
    & f(x) =
    \begin{cases}
      C_0, & x = 0 \\
      C_1, & x = 1 \\
      \ldots \\
      C_{k - 1}, & x = k - 1 \\
      \frac{a x + b(x)}{d}, & x \geq k
    \end{cases} \\
    & f(x) =
    \begin{cases}
      C_0, & x = 0 \\
      C_1, & x = 1 \\
      \ldots \\
      C_{k - 1}, & x = k - 1 \\
      \lambda, & x \geq k
    \end{cases}
  \end{align}
  где \(C_0, C_1, \ldots C_{k - 1} \in \N_0 \cup \{\lambda\}\),
  \(b(x)\) --- целочисленная периодическая функция с предпериодом \(x_0\) и
  периодом \(d\),
  причем \(b(x)\) такая, что \(\frac{a x + b(x)}{d}\) является
  неотрицательное целое число для всех \(x > x_0\).
  Число \(d\) называем шагом функции маневра и обозначим через \(d_{f}\).
\end{definition}

Обозначим множество всех функции маневра через \(\F_m\).

\begin{definition}
  \label{def:manoeuvre_function_switcher}
  Функцию с переключателем \((f, \varphi)\) называем функция маневра с
  переключателем,
  если выполняется следующие условия:
  \(f \in \F_m\), \(\varphi \in \Phi_p\) и \(d_f = T_{\varphi}\).
\end{definition}

Обозначим множество всех функции маневра с переключателем
через \(\Psi_m\).

Определим понятия обобщенной функции маневра c переключателем через индуктивное
определение.
\begin{definition}
  \label{def:generalized_manoeuvre_function}
  \begin{enumerate}
  \item Любая функция маневра с переключателем это обобщенная функция
    маневра с переключателем.
  \item Для любого \(n \in \N\) и \(m \in \N_0\)
    если \((f_0, \varphi_0)\), \((f_1, \varphi_1)\), \((f_2, \varphi_2)\),
    \ldots, \((f_n, \varphi_n)\) является обобщенной функции маневра с
    переключателем, то функции
    \((f', \varphi') = S_n[(f_0, \varphi_0), (f_1, \varphi_1), \ldots, (f_n, \varphi_n)]\)
    и \((f'', \varphi'') = R[f_0, \varphi_0]\) тоже является обобщенной
    функции маневра с переключателем.
  \end{enumerate}
\end{definition}

Обозначим множество всех обобщенных функции маневра с переключателем через
\(\Psi_2\).

\begin{definition}
  Функцию \(f\) называем обобщенная функция маневра, если существует
  \(\varphi \in \F_p\) такое что \((f, \varphi) \in \Psi_2\).
\end{definition}

Обозначим множество всех обобщенных функции маневра через \(\F_2\).

\clearpage

Определим еще одно понятия для доказательства теорем.

\begin{definition}
  \label{def:graph}
  Пусть у нас есть ориентированный нагруженный граф \(G = (V, E)\),
  где петли и кратные ребры разрешены.
  Выделим некторая вершина этого графа \(v_s\) которую будем
  называть стартовая вершина,
  еще выделим некторое подмножество множество вершин этого графа \(V_f\),
  которому не входить стартовая вершина \(v_s\),
  то есть \(V_f \subseteq V \setminus \{v_s\}\).
  Множество \(V_f\) будем называть множество финальных вершин.
  Пометим все не финальные вершины графа \(v \in V \setminus V_f\)
  меткой \((f_v, \varphi_v)\), где \((f_v, \varphi_v)\) --- функция с переключателем.
  Причем полустепень исхода вершины \(v\) совподаеть с рангом функции \(\varphi\).
  Каждую ребро входящий из \(v\) пометим через значения функции \(\varphi_v\), причем
  одно значения не должен повторятся. Называем полученный граф вычислительным графом.
\end{definition}

Вычислительный граф \(G\) принимаеть как вход некоторое \(x \in \N_0\) и дает другое
число используя следующий алгоритм:
\begin{enumerate}
\item Пусть \(v_a\) --- активная вершина и \(y\) --- текущая значения и \(v_a := v_s\), \(y := x\).
\item Если \(v_a \in V_f\), алгоритм закончится и в качестве ответа даем \(y\).
\item Находим \(v'\), такое что метка \((v, v')\) равно \(\varphi_{v_a}(y)\) и делаем
  \(y := f_{v_a}(y)\), \(v_a := v'\).
\item Повторяем 2 шаг.
\end{enumerate}

Если алгоритм при некотором \(x \in \N_0\) не закончится или в каком-то шаге
функции даёт неопределённость то считаем что вычислительный граф \(G\)
даёт неопределённость как ответ.

\begin{definition}
  \label{def:normal_graph}
  Пусть \(G\) вычислительный граф. Если в графе не существуеть вершиная которая входит в два
  простых цикла одновременно, и для каждой вершино верно то что:
  \begin{itemize}
  \item Либо все заходящие в эту вершины ребра исходить от одной вершины
  \item Либо все заходящие в эту вершины исходить из двух разных вершин и при этом эта вершина
    входит в только одну простую цикл.
  \end{itemize}
  Тогда граф \(G\) называется нормальный вычислительный граф.
\end{definition}

\begin{definition}
  \label{def:graph_function}
  Вычислительный граф \(G\) вычисляет функцию \(f_G\), если \(G\) при входном значении \(x\)
  даёт выходное значения \(f(x)\).
\end{definition}

Определим некоторые операции над вычислительными графами.

\begin{definition}
  \label{def:duplicate}
  Пусть дано вычислительный граф \(G\) и его вершина \(v \in V \setminus V_f\).
  И пусть этому вершину заходить несколько ребер, причом они исходить более чем одного вершин.
  Обозначим эти вершины через \(v_1, v_2, \ldots, v_n\).
  Тогда определим операцию дупликации над парой \((G, v)\) следующим образом:
  \begin{enumerate}
  \item Добавим новую вершину \(v'\) к графу \(G\) и пометим его таким же меткой
    \((f_g, \varphi_g)\), как у \(v\).
    Соответсвенно из него будет исходить ребра с такими же метками как у вершины \(v\)
  \item Удалим все ребра исходящий из \(v_1\) и заходящий к \(v\) и проводим все эти
    ребра от \(v_1\) к \(v'\).
  \item Дальше есть два случая:
    \begin{itemize}
    \item Исходящое ребро от \(v\) с меткой \(a\) не является петлой и заходить к вершину
      \(v'_1\). Тогда исходящое ребро от \(v'\) с меткой \(a\) заходить к вершину \(v'_1\).
    \item Исходящое ребро от \(v\) с меткой \(a\) является петлой.
      Тогда исходящое ребро от \(v'\) с меткой \(a\) тоже будет петлой
    \end{itemize}
  \end{enumerate}
\end{definition}

\begin{definition}
  \label{def:unite}
  Пусть дано нормальный вычислительный граф \(G\) и его вершина \(v \in V \setminus V_f\).
  
\end{definition}

\clearpage

\section{Классические результаты}

\begin{theorem}
  \label{theor:one_counter}
  \(J_1\) состоит из периодических функции и функции следующего вида:
  \begin{equation*}
    f(x) =
    \begin{cases}
      C_0, & x = 0 \\
      C_1, & x = 1 \\
      \ldots \\
      C_{k - 1}, & x = k - 1\\
      x + c, & x \geq k
    \end{cases}
  \end{equation*}
  где \(k, c, C_0, C_1, \ldots, C_{k - 1} \in \N_0\).
\end{theorem}

\begin{theorem}
  \label{theor:three_counter}
  \(J_3\) совпадаеть с классом частично рекурсивных функции от одной переменной.
\end{theorem}

\begin{theorem}
  \label{theor:two_counter_special}
  Пусть у нас есть кодировка \(x \mapsto 2^x\).
  В таком кодировке любая частично рекурсивная функция вычислима на автоматах с
  двумя счётчиками.
\end{theorem}

\clearpage

\section{Основные результаты}

\begin{theorem}
  \(\F_2 = J_2\).
\end{theorem}

\begin{theorem}
  Любая функция \(f\) из \(J_2\) имеет вид:
  \begin{equation}
    \label{eq:j2}
    f(x) = \frac{a(x) \cdot x + b(x)}{d(x)}
  \end{equation}
  где \(a(x)\), \(b(x)\) и \(d(x)\) псевдопериодическые функции.
\end{theorem}

\clearpage

\section{Леммы и доказательства}

\begin{lemma}
  \label{lemma:manoeuvre}
  Пусть дано автомат автомат \(\A\) c 2 счётчиками.
  Существует
\end{lemma}

\clearpage

\begin{thebibliography}{}
\bibitem{litautomatatheory} Кудрявцев В.Б., Алешин С.В., Подколзин А.С.
  \textit{Введение в теорию автоматов}. Наука, 1985.
\bibitem{litautomatalanguages} Д. Хопкрофт, Р. Мотвани, Д. Ульман
  \textit{Введение в теорию автоматов, языков и вычислений}. 2-е изд. :
  Пер. с англ. --- Москва, Издательский дом ``Вильямс'', 2002.
\bibitem{litautomatacounters} Кузьмин Е.В., Соколов В.А.
  \textit{Автоматные счетчиковые машины}. Ярославль, 2012.
\end{thebibliography}

\end{document}