\documentclass[14pt, a4paper, oneside]{article}

\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{fontspec}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{amsthm}
\usepackage{indentfirst}
\usepackage[left=3cm,right=1cm,
    top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}

\setmainfont{Liberation Serif}

\newtheorem{definition}{Определение}
\newtheorem{theorem}{Теорема}[section]
\newtheorem{consequence}{Следствие}[section]
\newtheorem{note}{Замечание}
\newtheorem{lemma}{Лемма}
\renewcommand{\thetheorem}{\arabic{theorem}}
\renewcommand{\theconsequence}{\arabic{consequence}}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\F}{\mathcal{F}}

\begin{document}

\thispagestyle{empty}

\begin{center}
  \Large
  МОСКОВСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ \\
  \bigskip
  имени М.В.Ломоносова \\
  \bigskip
  Филиал в г.Ташкенте \\
  \bigskip
  Факультет Прикладной Математики и Информатики \\
  \bigskip
  \hrule
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \textbf{Курсовая работа} \\
  \bigskip
  \textbf{Функции вычислимые через автоматы с двумя счётчиками} \\
  \bigskip
  \bigskip
  \Large
  Подготовил: \\
  Студент третьего курса факультета ПМиИ \\
  Илхомов Мухаммад Муроджон угли \\
  \bigskip
  \bigskip
  Научный руководитель: \\
  Волков Николай Юрьевич \\
  \bigskip
  \hrule
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \textbf{2022}
\end{center}

\clearpage

\linespread{1.25}

\normalsize
\tableofcontents

\clearpage

\section{Введение}

\clearpage

\section{Основные определение и понятия}

Обозначим множества натуральных чисел через \(\N\). Положим \(\N_0 = N \cup \{0\}\).  Определения
автомата совпадает с определением приведенное в \cite{litautomatatheory}.

В этой работе определение автомата будет такой:
\begin{definition}
  \label{def:automata}
  Автомат с \(n\) счётчиками называется семёрка \(\A = (A, Q, Q_f, B, \varphi, \bar{\psi}, q_0)\),
  где:
  \begin{itemize}
  \item \(A=\{0, 1\} n\) --- входной алфавит
  \item \(Q\) --- множество состояний
  \item \(Q_f\) --- множество финальных состояний
  \item \(B=\{-1, 0, 1\}^n\) --- выходной алфавит
  \item \(\varphi: (Q \setminus Q_f) \times A \rightarrow Q\) --- функция переходов
  \item \(\bar{\psi}: (Q \setminus Q_f) \times A \rightarrow B\) --- функция выхода, которая состоит
    из \(n\) функции: \linebreak \(\bar{\psi} = (\psi_1, \psi_2, \ldots, \psi_n)\).
  \end{itemize}
  При этом есть ограничения для \(\bar{\psi}\):
  \begin{equation}
    \label{eq:constraint}
    \forall i \in \{1, 2, \ldots, n\}\ (x_i = 0 \Rightarrow
    \psi_i(q, x_1, x_2, \ldots, x_i, \ldots, x_n) \geq 0)
  \end{equation}
\end{definition}

\begin{definition}
  \label{def:initialized_automata}
  Упорядоченного множество \((\A, z_1 0, z_2 0, \ldots, z_n 0)\) называется инициализированный
  автомат с \(n\) счётчиками, где
  \begin{itemize}
  \item \(\A\) --- автомат с \(n\) счётчиками
  \item \(z_i 0 \in \N_0\) --- начальным значениям \(i\)-счётчика, где \(i \in \{1, 2, \ldots, n\}\)
  \end{itemize}
\end{definition}

\begin{definition}
  \label{def:canonical}
  Пусть у нас есть инициализированный автомат с \(n\) счётчиками
  \((\A, z_1 0, z_2 0, \ldots, z_n 0)\).  Каноническими уравнениями называется система
  \ref{eq:canonical}
  \begin{equation}
    \label{eq:canonical}
    \begin{cases}
      q(0) = q_0 \\
      z_1(0) = z_1 0 \\
      z_2(0) = z_2 0 \\
      \ldots \\
      z_n(0) = z_n 0 \\
      q(t + 1) = \varphi(q(t), a(t)) \\
      z_1(t + 1) = z_1(t) + \psi_1(q(t), a(t)) \\
      z_2(t + 1) = z_2(t) + \psi_2(q(t), a(t)) \\
      \ldots \\
      z_n(t + 1) = z_n(t) + \psi_n(q(t), a(t))
    \end{cases}
  \end{equation}
  где
  \begin{align*}
    & t \in \N_0 \\
    & a(t) = (\text{sign}(z_1(t)), \text{sign}(z_2(t)), \ldots,
      \text{sign}(z_n(t))) \\
    & \text{sign}(x) =
      \begin{cases}
        -1, &x \in (-\infty; 0) \\
        0, &x = 0 \\
        1, &x \in (0; \infty)
      \end{cases} \\
  \end{align*}
\end{definition}

\begin{definition}
  \label{def:behaviour}
  Пусть у нас есть автомат с \(n\) счётчиками \((\A, z_1 0, z_2 0, \ldots, z_n 0)\).
  \begin{itemize}
  \item Если существует момент времени \(t'\), такое что \(q(t') \in Q_f\), тогда поведением
    инициализированного автомата с \(n\) счётчиками называется конечная последовательность:
    \begin{align*}
      & (q(0), z_1(0), z_2(0), \ldots, z_n(0)) \\
      & (q(1), z_1(1), z_2(1), \ldots, z_n(1)) \\
      & \ldots, \\
      & (q(t'), z_1(t'), z_2(t'), \ldots, z_n(t'))
    \end{align*}
    В этом случае говорится инициализированный автомат с \(n\) счётчиками остановится.
  \item Если не существует момент времени \(t'\), такое что \(q(t') \in Q_f\), тогда поведением
    инициализированного автомата с \(n\) счётчиками называется бесконечная последовательность:
    \begin{align*}
      & (q(0), z_1(0), z_2(0), \ldots, z_n(0)) \\
      & (q(1), z_1(1), z_2(1), \ldots, z_n(1)) \\
      & \ldots, \\
      & (q(t), z_1(t), z_2(t), \ldots, z_n(t')) \\
      & \ldots
    \end{align*}
    В этом случае говорится инициализированный автомат с \(n\) счётчиками не остановится.
  \end{itemize}
\end{definition}

Автомат с \(n\) счётчиками можно рассмотреть как автомат соединенные с \(n\) внешними счётчиками,
каждый который может хранить неотрицательное число.  Автомат может видеть только то что, каждый
счётчик равно нулю или нет.  Каждый момент времени автомат может менять значения счётчика не более
чем на одну единицу, при этом значения счётчиков всегда должен остаться неотрицательным.
Ограничение \ref{eq:constraint} как раз таки обеспечивает неотрицательность счётчиков.

Рассмотрим автомат с двумя счётчиками.

\begin{definition}
  \label{def:manoeuvre}
  Пусть у нас есть инициализированный автомат с двумя счётчиками.  Конечным манёвром называется
  поведение автомата от момента времени \(t_1\) до \(t_2\):
  \begin{align*}
    & (q(t_1), z_1(t_1), z_2(t_1)), \\
    & (q(t_1 + 1), z_1(t_1 + 1), z_2(t_1 + 1)), \\
    & \ldots, \\
    & (q(t_2), z_1(t_2), z_2(t_2))
  \end{align*}
  если выполняется один из следующих условий:
  \begin{align*}
    & \begin{cases}
        z_1(t_1) = 0 \\
        \forall t (t_1 \leq t < t_2 \Rightarrow q(t) \notin Q_f) \\
        \forall t (t_1 < t < t_2 \Rightarrow z_2(t) \neq 0) \\
        z_2(t_2) = 0
      \end{cases}
    \begin{cases}
      z_2(t_1) = 0 \\
      \forall t (t_1 \leq t < t_2 \Rightarrow q(t) \notin Q_f) \\
      \forall t (t_1 < t < t_2 \Rightarrow z_1(t) \neq 0) \\
      z_1(t_2) = 0
    \end{cases}
  \end{align*}
\end{definition}

\begin{definition}
  \label{def:notfull_manoeuvre}
  Пусть у нас есть инициализированный автомат с двумя счётчиками.  Непольным манёвром называется
  поведение автомата от момента времени \(t_1\) до \(t_2\):
  \begin{align*}
    & (q(t_1), z_1(t_1), z_2(t_1)), \\
    & (q(t_1 + 1), z_1(t_1 + 1), z_2(t_1 + 1)), \\
    & \ldots, \\
    & (q(t_2), z_1(t_2), z_2(t_2))
  \end{align*}
  если выполняется один из следующих условий:
  \begin{align*}
    & \begin{cases}
        z_1(t_1) = 0 \\
        \forall t (t_1 < t \leq t_2 \Rightarrow z_2(t) \neq 0) \\
        q(t_2) \in Q_f
      \end{cases}
    \begin{cases}
      z_2(t_1) = 0 \\
      \forall t (t_1 < t \leq t_2 \Rightarrow z_1(t) \neq 0) \\
      q(t_2) \in Q_f
    \end{cases}
  \end{align*}
\end{definition}

\begin{definition}
  \label{def:infinity_manoeuvre}
  Пусть у нас есть инициализированный автомат с двумя счётчиками.  Бесконечным манёвром называется
  поведение автомата от момента времени \(t_1\):
  \begin{align*}
    & (q(t_1), z_1(t_1), z_2(t_1)), \\
    & (q(t_1 + 1), z_1(t_1 + 1), z_2(t_1 + 1)), \\
    & \ldots
  \end{align*}
  если выполняется один из следующих условий:
  \begin{align*}
    \begin{cases}
      z_1(t_1) = 0 \\
      \forall t (t_1< t \Rightarrow (z_2(t) \neq 0 \wedge q(t) \notin Q_f) \\
    \end{cases}
    \begin{cases}
      z_2(t_1) = 0 \\
      \forall t (t_1< t \Rightarrow (z_1(t) \neq 0 \wedge q(t) \notin Q_f) \\
    \end{cases}
  \end{align*}
\end{definition}

Мы рассмотрим вычислимость частично определенных функции из \(m\) переменных, то есть функции,
которые имеет вид: \({f: M \rightarrow \N_0 \cup \{\lambda\}}\), где \(M \subseteq \N_0 m\).  Будем
записать \(f(x_1, \ldots, x_m) = \lambda\), если \(f\) в точке \((x_1, \ldots, x_m)\) неопределено.

\begin{definition}
  \label{def:computability}
  Будем говорить что автомат \(\A\) с \(n\) счётчиками вычисляет функция \(m\)-переменных
  \(f_{\A}: \N m_0 \rightarrow \N_0\) (где \(m \leq n\)), если:
  \begin{itemize}
  \item \(f_{\A}(x_1, x_2, \ldots, x_m) = y\) и инициализированный автомат
    \((\A, x_1, x_2, \ldots, x_m, 0, \ldots, 0)\) остановится, причем в момент остановки \(t'\)
    значения одного счётчика равно \(y\), а всех остальных равен \(0\)
  \item \(f_{\A}(x_1, x_2, \ldots, x_m) = \lambda\) и инициализированный автомат с \(n\) счётчиками
    \((\A, x_1, x_2, \ldots, x_m, 0, \ldots, 0)\) остановится, причем в момент остановки \(t'\)
    существует ненулевой счётчик кроме первого счётчика
  \item \(f_{\A}(x_1, x_2, \ldots, x_m) = \lambda\) и инициализированный автомат с \(n\) счётчиками
    \((\A, x_1, x_2, \ldots, x_m, 0, \ldots, 0)\) не остановится
  \end{itemize}
\end{definition}

Мы рассмотрим только частично определенных функции одной переменной.  Обозначим через \(J_n\)
множество всех частично определенных функции одной переменной, которые вычислимы через автоматы с
\(n\) счётчиками.  Очевидно что для любого \(n\) верно \(J_n \subseteq J_{n + 1}\).

Обозначим через \(\F\) все частично определенных функции одной переменной.

Множество значений функции \(f \in \F\) обозначим через \(Im(f)\).

\begin{definition}
  \label{def:switcher}
  Пусть \(\varphi \in \F\).  \(\varphi\) называется переключательной функцией, если
  \(Im(\varphi)< \infty\).
\end{definition}

Обозначим через \(\Phi\) множество всех переключательных функции.

\begin{definition}
  \label{def:switcher_rang}
  Пусть \(\varphi \in \Phi\).  \(Im(\varphi)\) называется рангом функции \(\varphi\).
\end{definition}

\begin{definition}
  \label{def:function_with_switcher}
  Пару \((f, \varphi)\) называется функцию с переключателем, если \(f \in \F, \varphi \in \Phi\) и
  \(\forall x [f(x) = \lambda \Leftrightarrow \varphi(x) = \lambda]\).  \(f\) называется основной
  функцией.
\end{definition}

\begin{definition}
  \label{def:generalized_superposition}
  Пусть \(n \in \N\), \((f_0, \varphi_0)\), \((f_1, \varphi_1)\), \((f_2, \varphi_2)\), \ldots,
  \((f_n, \varphi_n)\) --- функции с переключателями и \(E(\varphi_0) = \{k_1, k_2, \ldots, k_n\}\).
  Тогда определим оператор обобщенной суперпозиции \(S_n\) следующим образом: если
  \((f, \varphi) = S_n[(f_0, \varphi_0), (f_1, \varphi_1), (f_2, \varphi_2), \ldots (f_n,
  \varphi_n)]\), то \(f\) и \(\varphi\) имеет вид
  \begin{align}
    \label{eq:generalized_superposition}
    & f(x) =
      \begin{cases}
        f_1(f_0(x)), & \varphi_0(x) = k_1 \\
        f_2(f_0(x)), & \varphi_0(x) = k_2 \\
        \ldots \\
        f_n(f_0(x)), & \varphi_0(x) = k_n
      \end{cases} \\
    & \varphi(x) =
      \begin{cases}
        \varphi_1(f_0(x)), & \varphi_0(x) = k_1 \\
        \varphi_2(f_0(x)), & \varphi_0(x) = k_2 \\
        \ldots \\
        \varphi_n(f_0(x)), & \varphi_0(x) = k_n
      \end{cases}
  \end{align}
  При этом для любого \(x \in \N_0\) если \(f_0(x) = \lambda\) (соответственно
  \(\varphi_0(x) = \lambda\)), то \(f(x) = \lambda\) и \(\varphi(x) = \lambda\)
\end{definition}

Прежде чем определять следующий оператор введем некоторые обозначения:
\begin{itemize}
\item \(f k(x)\) --- это \(k\) раз применения функция \(f\) на \(x \in \N_0\).  Если для \(x\)
  существует \(l \in \overline{1, k}\), такая что \(f l(x) = \lambda\), то \(f k(x) = \lambda\).
\item Пусть \((f, \varphi)\) --- функция с переключателем.  Тогда для любого \(a \in \N_0\)
  определим следующие множества:
  \begin{align*}
    & \Delta_0(a) = \{x \in \N_0 | \varphi(x) = a\} \\
    & \Delta_{k + 1}(a) = \{x \in \Delta_{k} | \varphi(f {k + 1}(x)) = a\},\ \text{где}\ k \geq 0 \\
    & X_0(a) = \N_0 \setminus \Delta_0(a) \\
    & X_{k + 1}(a) = \Delta_{k}(a) \setminus \Delta_{k + 1}(a),\ \text{где}\ k \geq 0 \\
    & X_{\infty}(a) = \N_0 \setminus \bigcup_{k \geq 0} X_k(a)
  \end{align*}
\end{itemize}

\begin{definition}
  \label{def:special_recursion}
  Пусть \((f_0, \varphi_0)\) --- функция с переключателем Тогда определим оператор специальной
  рекурсии \(R\) следующим образом: Если \((f, \varphi) = R_a[(f_0, \varphi_0)]\), то \(f\) и
  \(\varphi_0\) имеет вид:
  \begin{align}
    \label{eq:generalized_superposition}
    & f(x) =
      \begin{cases}
        f {k + 1}_0(x), & x \in X_k(a) \\
        \lambda, & x \in X_{\infty}(a)
      \end{cases} \\
    & \varphi(x) =
      \begin{cases}
        \varphi_0(x), & x \in X_0(a) \\
        \varphi_0(f_0 k(x)), & x \in X_k(a), k \geq 1 \\
        \lambda, & x \in X_{\infty}(a)
      \end{cases}
  \end{align}
  При этом для любого \(x \in \N_0\) если \(f_0 l(x) = \lambda\) (где \(1 \geq l \geq k\)), то
  \(f(x) = \lambda\) и \(\varphi(x) = \lambda\)
\end{definition}

\begin{definition}
  \label{def:periodic}
  Функцию \(f \in \F\) называется периодичным, если существует \(T \in \N\) и \(x_0 \in \N_0\),
  такое что для любого \(x > x_0\) и для любого \(k \in \N_0\) верно \(f(x) = f(x + kT)\).
\end{definition}

Обозначим минимальный период функции \(\varphi\) через \(T_{\varphi}\).

Обозначим множество всех периодичных функции через \(\Phi_p\).  Очевидно что
\(\Phi_p \subset \Phi\).

\begin{definition}
  \label{def:pseudoperiodic}
  Функцию \(f \in \F\) называется псевдопериодичным, если существует \(x_0 \in \N_0\), такое что для
  любого \(x > x_0\) существует \(T \in \N\), такое что для любого \(k \in \N_0\) верно
  \(f(x) = f(x + kT)\).
\end{definition}

Обозначим множество всех псевдоперидочных функции через \(\F_p\).  Очевидно что
\(\Phi_p \subset \F_p\).

\begin{definition}
  \label{def:manoeuvre_function}
  Функцию \(f \in \F\) называется функцию маневра если она имеет один из следующих видов:
  \begin{align}
    \label{eq:manoeuvre_function}
    & f(x) =
      \begin{cases}
        C_0, & x = 0 \\
        C_1, & x = 1 \\
        \ldots \\
        C_k, & x = k \\
        \frac{a x + b(x)}{d}, & x > k
      \end{cases} \\
    & f(x) =
      \begin{cases}
        C_0, & x = 0 \\
        C_1, & x = 1 \\
        \ldots \\
        C_k, & x = k \\
        \lambda, & x > k
      \end{cases}
  \end{align}
  где \(C_0, C_1, \ldots C_k \in \N_0 \cup \{\lambda\}\), \(b(x)\) --- целочисленная периодическая
  функция с предпериодом \(k\) и периодом \(d\), причем \(b(x)\) такая, что \(\frac{a x + b(x)}{d}\)
  является неотрицательное целое число для всех \(x > k\).  Число \(d\) называем шагом функции
  маневра и обозначим через \(d_{f}\).  А число \(k\) предшагом функции маневра и обозначим через
  \(k_f\).
\end{definition}

Обозначим множество всех функции маневра через \(\F_m\).

\begin{definition}
  \label{def:manoeuvre_function_switcher}
  Функцию с переключателем \((f, \varphi)\) называем функция маневра с переключателем, если
  выполняется следующие условия: \(f \in \F_m\), \(\varphi \in \Phi_p\) и \(d_f = T_{\varphi}\).
\end{definition}

Обозначим множество всех функции маневра с переключателем через \(\Psi_m\).

\begin{definition}
  \label{def:generalized_manoeuvre_function_with_switcher}
  Определим обобщенную функцию маневра с переключателем через индуктивное определение:
  \begin{enumerate}
  \item Любая функция маневра с переключателем это обобщенная функция маневра с переключателем.
  \item Для любого \(n \in \N\) и \(m \in \N_0\) если \((f_0, \varphi_0)\), \((f_1, \varphi_1)\),
    \((f_2, \varphi_2)\), \ldots, \((f_n, \varphi_n)\) является обобщенной функции маневра с
    переключателем, то функции
    \((f', \varphi') = S_n[(f_0, \varphi_0), (f_1, \varphi_1), \ldots, (f_n, \varphi_n)]\) и
    \((f'', \varphi'') = R_a[(f_0, \varphi_0)]\) тоже является обобщенной функции маневра с
    переключателем.
  \end{enumerate}
\end{definition}

Обозначим множество всех обобщенных функции маневра с переключателем через \(\Psi_2\).

\begin{definition}
  \label{def:generalized_manoeuvre_function}
  Функцию \(f\) называем обобщенная функция маневра, если существует \(\varphi \in \F_p\) такое что
  \((f, \varphi) \in \Psi_2\).
\end{definition}

Обозначим множество всех обобщенных функции маневра через \(\F_2\).

Определим еще одно понятия для доказательства теорем.

\begin{definition}
  \label{def:graph}
  Пусть дано ориентированный нагруженный граф \(G = (V, E)\), где петли разрешены, но кратные
  (соответственно и кратные петли) не разрешены и дано множество \(\Psi \subseteq \F \times \Phi\).
  Выделим некоторая вершина этого графа \(v_s\), которую будем называть стартовая вершина.  Еще
  выделим некоторое подмножество множество вершин этого графа \(V_f\), которому не входить стартовая
  вершина \(v_s\), то есть \(V_f \subseteq V \setminus \{v_s\}\).  Множество \(V_f\) будем называть
  множество финальных вершин.  Пометим все не финальные вершины графа \(v \in V \setminus V_f\)
  меткой \((f_v, \varphi_v)\), где \((f_v, \varphi_v) \in \Psi\) Причем полустепень исхода вершины
  \(v\) совпадает с рангом функции \(\varphi\).  Каждую ребро исходящий из \(v\) пометим через
  значения функции \(\varphi_v\), причем одно значения не должен повторятся.  При этом должен
  выполнятся условия, что для любой вершины все заходящие в эту вершины ребра должны быть
  одинаковыми и ребра заходящие в двух разных вершин может иметь одинаковые метки тогда и только
  тогда, когда эти вершины имеет одинаковые метки.  Называем полученный граф вычислительным графом
  над множеством \(\Psi\).
\end{definition}

Вычислительный граф \(G\) принимает как вход некоторое \(x \in \N_0\) и дает другое число используя
следующий алгоритм:
\begin{enumerate}
\item Пусть \(v_a\) --- активная вершина и \(y\) --- текущая значения и \(v_a := v_s\), \(y := x\).
\item Если \(v_a \in V_f\), алгоритм закончится и в качестве ответа даем \(y\).
\item Находим \(v'\), такое что метка \((v, v')\) равно \(\varphi_{v_a}(y)\) и делаем
  \(y := f_{v_a}(y)\), \(v_a := v'\).
\item Повторяем 2 шаг.
\end{enumerate}

Если алгоритм при некотором \(x \in \N_0\) не закончится или в каком-то шаге функции даёт
неопределённость, то считаем что вычислительный граф \(G\) даёт неопределённость как ответ.

\begin{definition}
  \label{def:normal_graph}
  Пусть \(G\) вычислительный граф над множеством \(\Psi\).  Если в графе не существует вершина,
  которая входит в два простых цикла одновременно, и для каждой вершины верно, то что:
  \begin{itemize}
  \item Либо все заходящие в эту вершины ребра исходить от одной вершины
  \item Либо все заходящие в эту вершины исходить из двух разных вершин и при этом эта вершина
    входит в только одну простому циклу.
  \end{itemize}
  Тогда граф \(G\) называется нормальным вычислительныи графом.
\end{definition}

\begin{definition}
  \label{def:graph_function}
  Вычислительный граф \(G\) над множеством \(\Psi\) вычисляет функцию \(f_G\), если \(G\) при
  входном значении \(x\) даёт выходное значения \(f(x)\).
\end{definition}

Определим некоторые операции над вычислительными графами.

\begin{definition}
  \label{def:duplicate}
  Пусть дано вычислительный граф \(G\) над множеством \(\Psi\) и его вершина
  \(v \in V \setminus V_f\).  И пусть этому вершину заходить несколько ребер, причём они исходят
  более чем одного вершин.  Обозначим эти вершины через \(v_1, v_2, \ldots, v_n\).  Тогда определим
  операцию дупликации над парой \((G, v)\) следующим образом:
  \begin{enumerate}
  \item Добавим новую вершину \(v'\) к графу \(G\) и пометим его таким же меткой
    \((f_g, \varphi_g)\), как у \(v\).  Соответственно из него будет исходить ребра с такими же
    метками как у вершины \(v\)
  \item Удалим все ребра исходящий из \(v_1\) и заходящий к \(v\) и проводим все эти ребра от
    \(v_1\) к \(v'\).
  \item Дальше есть два случая:
    \begin{itemize}
    \item Исходящее ребро от \(v\) с меткой \(a\) не является петлёй и заходить к вершине
      \(v'_1\). Тогда исходящее ребро от \(v'\) с меткой \(a\) заходить к вершине \(v'_1\)
    \item Исходящее ребро от \(v\) с меткой \(a\) является петлёй.  Тогда исходящее ребро от \(v'\)
      с меткой \(a\) тоже будет петлёй
    \end{itemize}
  \end{enumerate}
\end{definition}

\begin{definition}
  \label{def:unite}
  Пусть дано нормальный вычислительный граф \(G\) над множеством \(\Psi\) и его вершина
  \(v \in V \setminus V_f\).  Пусть из вершины \(v\) исходит ребра, которые заходить к вершинам
  \(v_1, v_2, \ldots, v_n\) и имеет метки \(k_1, k_2, \ldots, k_n\) соответственно. При этом
  \(v_1, v_2, ..., v_n\) не имеет петли.  Тогда определим операцию объединение следующим образом:
  \begin{enumerate}
  \item Добавим вершину \(v'\), которая имеет метку равную
    \(S_n[(f_v, \varphi_v), (f_1, \varphi_1), (f_2, \varphi_2), \ldots, (f_n, \varphi_n)]\).  Здесь
    \((f_i, \varphi_i)\) равно:
    \begin{itemize}
    \item \((f_{v_i}, \varphi_{v_i})\), если \(v_i \in V \setminus V_f\)
    \item \((I, Const_{k_i})\), если \(v_i \in V_f\).  Здесь
      \((\forall x \in \N_0)[I(x) = x \wedge Const_{k_i}(x) = k_i]\)
    \end{itemize}
  \item Проводим ребро с меткой \(a\) исходящий от \(v'\) к вершине, которому заходить ребро с той
    же меткой исходящий от вершин \(v_1, v_2, \ldots, v_n\)
  \item Удалим вершины \(v, v_1, v_2, \ldots, v_n\)
  \item Проводим все ребра которые заходили в вершину \(v\), к вершину \(v'\)
  \end{enumerate}
\end{definition}

\begin{definition}
  \label{def:eliminate_loop}
  Пусть дано нормальный вычислительный граф \(G\) над множеством \(\Psi\) и его вершина
  \(v \in V \setminus V_f\).  Пусть вершина \(v\) имеет петлю по метке \(a\). Тогда операцию
  устранения петли определим так:
  \begin{enumerate}
  \item Удалим петлю с меткой \(a\)
  \item Меняем метку вершины \(v\) на \(R_a[(f_v, \varphi_v)]\)
  \end{enumerate}
\end{definition}

\clearpage

\section{Классические результаты}

\begin{theorem}
  \label{theor:one_counter}
  \(J_1\) состоит из периодических функции и функции следующего вида:
  \begin{equation*}
    f(x) =
    \begin{cases}
      C_0, & x = 0 \\
      C_1, & x = 1 \\
      \ldots \\
      C_{k - 1}, & x = k - 1\\
      x + c, & x \geq k
    \end{cases}
  \end{equation*}
  где \(k, c, C_0, C_1, \ldots, C_{k - 1} \in \N_0\).
\end{theorem}

\begin{theorem}
  \label{theor:three_counter}
  \(J_3\) совпадаеть с классом частично рекурсивных функции от одной переменной.
\end{theorem}

\begin{theorem}
  \label{theor:two_counter_special}
  Пусть у нас есть кодировка \(x \mapsto 2^x\).  В таком кодировке любая частично рекурсивная
  функция вычислима на автоматах с двумя счётчиками.
\end{theorem}

\clearpage

\section{Основные результаты}

\begin{theorem}
  \label{computable_functions}
  \(\F_2 = J_2\).
\end{theorem}

\begin{theorem}
  \label{expression}
  Любая функция \(f\) из \(J_2\) имеет вид:
  \begin{equation}
    \label{eq:j2}
    f(x) = \frac{a(x) \cdot x + b(x)}{d(x)}
  \end{equation}
  где \(a(x)\), \(b(x)\) и \(d(x)\) псевдопериодическые функции.
\end{theorem}

\begin{consequence}
  Функции \(f(x) = 2^x\) и \(g(x) = \lfloor \log_2 x \rfloor\) не вычислимы через автоматы
  с двумя счётчиками.
\end{consequence}

\clearpage

\section{Леммы и доказательства}

\begin{lemma}
  \label{lemma:manoeuvre}
  Пусть дано автомат с 2 счётчиками \((\A)\).  Тогда существует такое функция \(f \in \F_m\), такое
  что для любого значения \(y\) верно:
  \begin{itemize}
  \item Если инициализированный автомат \((\A, y, 0)\) совершает конечный маневр и этот маневр
    закончится момент времени \(t'\), тогда \(z_1(t') = 0, z_2(t') = f(y)\)
  \item Если инициализированный автомат \((\A, y, 0)\) совершает непольный маневр и этот маневр
    закончится момент времени \(t'\), при этом \(z_2(t') = 0\) тогда \(z_1(t') = f(y)\)
  \item Если инициализированный автомат \((\A, y, 0)\) совершает непольный маневр и этот маневр
    закончится момент времени \(t'\), при этом \(z_2(t') \neq 0\) тогда \(f(y) = \lambda\)
  \item Если инициализированный автомат \((\A, y, 0)\) совершает бесконечный маневр, тогда
    \(f(y) = \lambda\)
  \end{itemize}
\end{lemma}

\begin{proof}
  Пусть у нас есть автомат с двумя счётчиками \(\A\) и количество состоянии этого автомата \(N\).
  Тогда предшаг функции маневра \(f\) будет равно \(N(N + 1) + 1\).  Рассмотрим как бывает маневры
  зависимости от начального значения счётчика \(y\).
  \begin{enumerate}
  \item Пусть \(y \leq N(N + 1)\). Тогда значения функции \(f(y)\) выбираем таким образом, чтобы это
    значения удовлетворял условия леммы.
  \item Пусть \(y \geq N(N + 1) + 1\). Рассмотрим поведения инциализированного автомата
    \((\A, y , 0)\).  Есть два варианта:
    \begin{enumerate}
    \item Приходит момент времени \(t'\), такое что \(z_2(t') > N + 1\). При этом существует
      момент времени \(t''\), такое что \(z_2(t'') > 0 \wedge q(t') = q(t'')\)
      Рассмотрим поведения автомата до момента времени \(t_0\):
      \begin{align*}
        & (q(0), z_1(0), z_2(0), \ldots, z_n(0)) \\
        & (q(1), z_1(1), z_2(1), \ldots, z_n(1)) \\
        & \ldots, \\
        & (q(t_0), z_1(t_0), z_2(t_0), \ldots, z_n(t_0))
      \end{align*}
      Поскольку у нас всего \(N\) состояний и \(t_0 > N + 1\), существует моменты времени
      \(i, j\), такие что \(0 < i < j \leq t_0\) и для которых верно \(q(i) = q(j)\).
      Причем, из-за того о
      Тогда для любого \(t \geq t_0\),
      верно что \(z_2(t) > N + 1\).
    \end{enumerate}
  \end{enumerate}
\end{proof}

\begin{lemma}
  \label{lemma:automata_to_graph}
  Пусть дано автомат \(\A\) и пусть это автомат вычисляет функция
  \(f_{\A} : \N_0 \rightarrow \N_0\).  Тогда существует вычислительный граф над множеством
  \(\Psi_m\), который вычисляет ту же функцию \(f_{\A}\).
\end{lemma}

\begin{lemma}
  \label{lemma:graph_to_automata}
  Пусть дано вычислительный граф \(G\) над множеством \(\Psi_m\) и пусть это граф вычисляет функция
  \(f_G : \N_0 \rightarrow \N_0\).  Тогда существует автомат с двумя счётчиками который, который
  вычисляет ту же функцию \(f_{G}\).
\end{lemma}

\begin{lemma}
  \label{lemma:duplicate_closure}
  Пусть дано вычислительный граф \(G\) над множеством \(\Psi \subseteq \F \times \Phi\), который
  вычисляет функцию \(f_G: \N_0 \rightarrow \N_0\) и пусть \(v \in V \setminus V_f\).  Тогда граф
  \(G'\), полученное применением операции дублирования над \((G, v)\) тоже вычисляет функцию
  \(f_G\).
\end{lemma}

\begin{lemma}
  \label{lemma:graph_to_normal_graph}
  Пусть дано вычислительный граф \(G\) над множеством \(\Psi \subseteq \F \times \Phi\), который
  вычисляет функцию \(f_G: \N_0 \rightarrow \N_0\).  Тогда можно построить нормальный вычислительный
  граф \(G'\), который тоже вычисляет функцию \(f_G\).
\end{lemma}

\begin{lemma}
  \label{lemma:unite_closure}
  Пусть дано норамальный вычислительный граф \(G\) над множеством \(\Psi \subseteq \F \times \Phi\),
  который вычисляет функцию \(f_G: \N_0 \rightarrow \N_0\) и пусть \(v \in V \setminus V_f\).  Тогда
  граф \(G'\), полученное применением операции объединение над \((G, v)\) тоже является нормальным
  вычислительным графом и тоже вычисляет функцию \(f_G\).
\end{lemma}

\begin{lemma}
  \label{lemma:eliminate_loop_closure}
  Пусть дано норамальный вычислительный граф \(G\) над множеством \(\Psi \subseteq \F \times \Phi\),
  который вычисляет функцию \(f_G: \N_0 \rightarrow \N_0\) и пусть \(v \in V \setminus V_f\).  Тогда
  граф \(G'\), полученное применением операции устранения петли над \((G, v)\) тоже является
  нормальным вычислительным графом и тоже вычисляет функцию \(f_G\).
\end{lemma}

\begin{lemma}
  \label{lemma:graph_to_function}
  Пусть дано нормальный вычислительный граф \(G\) над множеством \(\Psi_m\). Тогда функция \(f_G\)
  которая вычисляет граф является обобщенная функция маневра, то есть \(f_G \in \F_2\)
\end{lemma}

\begin{lemma}
  \label{lemma:function_to_graph}
  Пусть дано обобщенная функция маневра \(f\). Тогда можно построить нормальный вычислительный граф
  \(G_f\) над множеством \(\Psi_m\), который вычисляет функцию \(f\).
\end{lemma}

\begin{theorem}
  \label{computable_functions}
  \(\F_2 = J_2\).
\end{theorem}

\begin{theorem}
  \label{expression}
  Любая функция \(f\) из \(J_2\) имеет вид:
  \begin{equation}
    \label{eq:j2}
    f(x) = \frac{a(x) \cdot x + b(x)}{d(x)}
  \end{equation}
  где \(a(x)\), \(b(x)\) и \(d(x)\) псевдопериодическые функции.
\end{theorem}

\clearpage

\section{Заключения}

\clearpage

\begin{thebibliography}{}
\bibitem{litautomatacounters} Кузьмин Е.В., Соколов В.А.  \textit{Автоматные счетчиковые
    машины}. Ярославль, 2012.
\bibitem{litautomatatheory} Кудрявцев В.Б., Алешин С.В., Подколзин А.С.  \textit{Введение в теорию
    автоматов}. Наука, 1985.
\bibitem{litautomatalanguages} Д. Хопкрофт, Р. Мотвани, Д. Ульман \textit{Введение в теорию
    автоматов, языков и вычислений}. 2-е изд. : Пер. с англ. --- Москва, Издательский дом
  ``Вильямс'', 2002.
\end{thebibliography}

\end{document}