\documentclass[14pt, a4paper, oneside]{article}

\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{fontspec}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{amsthm}
\usepackage{indentfirst}
\usepackage[left=3cm,right=1cm,
    top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}

\setmainfont{Liberation Serif}

\newtheorem{definition}{Определение}
\newtheorem{theorem}{Теорема}[section]
\newtheorem{consequence}{Следствие}[section]
\newtheorem{note}{Замечание}
\newtheorem{lemma}{Лемма}
\renewcommand{\thetheorem}{\arabic{theorem}}
\renewcommand{\theconsequence}{\arabic{consequence}}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\F}{\mathcal{F}}
\newcommand{\G}{\mathcal{G}}
\newcommand{\M}{\mathcal{M}}

\begin{document}

\thispagestyle{empty}

\begin{center}
  \Large
  МОСКОВСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ \\
  \bigskip
  имени М.В.Ломоносова \\
  \bigskip
  Филиал в г.Ташкенте \\
  \bigskip
  Факультет Прикладной Математики и Информатики \\
  \bigskip
  \hrule
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \textbf{Курсовая работа} \\
  \bigskip
  \textbf{Функции вычислимые через автоматы с двумя счётчиками} \\
  \bigskip
  \bigskip
  \Large
  Подготовил: \\
  Студент третьего курса факультета ПМиИ \\
  Илхомов Мухаммад Муроджон угли \\
  \bigskip
  \bigskip
  Научный руководитель: \\
  Волков Николай Юрьевич \\
  \bigskip
  \hrule
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \textbf{2022}
\end{center}

\clearpage

\linespread{1.25}

\normalsize
\tableofcontents

\clearpage

\section{Введение}

\clearpage

\section{Основные определение и понятия}

Обозначим множества натуральных чисел через \(\N\), а множество целых чисел \(\Z\).
Положим \(\N_0 = N \cup \{0\}\).  Определения
автомата совпадает с определением приведенное в \cite{litautomatatheory}.

\begin{definition}
  \label{def:automata}
  Автомат с \(n\) счётчиками называется семёрка \(\A = (A, Q, Q_f, B, \varphi, \bar{\psi}, q_0)\),
  где:
  \begin{itemize}
  \item \(A=\{0, 1\}^n\) --- входной алфавит
  \item \(Q\) --- множество состояний
  \item \(Q_f\) --- множество финальных состояний
  \item \(B=\{-1, 0, 1\}^n\) --- выходной алфавит
  \item \(\varphi: (Q \setminus Q_f) \times A \rightarrow Q\) --- функция переходов
  \item \(\bar{\psi}: (Q \setminus Q_f) \times A \rightarrow B\) --- функция выхода, которая состоит
    из \(n\) функции: \(\bar{\psi} = (\psi_1, \psi_2, \ldots, \psi_n)\).
  \end{itemize}
  При этом есть ограничения для \(\bar{\psi}\):
  \begin{equation}
    \label{eq:constraint}
    \forall i \in \{1, 2, \ldots, n\}\ (x_i = 0 \Rightarrow
    \psi_i(q, x_1, x_2, \ldots, x_i, \ldots, x_n) \geq 0)
  \end{equation}
\end{definition}

\begin{definition}
  \label{def:initialized_automata}
  Упорядоченного множество \((\A, z_1^0, z_2^0, \ldots, z_n^0)\) называется инициализированный
  автомат с \(n\) счётчиками, где
  \begin{itemize}
  \item \(\A\) --- автомат с \(n\) счётчиками
  \item \(z_i^0 \in \N_0\) --- начальным значениям \(i\)-счётчика, где \(i \in \{1, 2, \ldots, n\}\)
  \end{itemize}
\end{definition}

\begin{definition}
  \label{def:canonical}
  Пусть у нас есть инициализированный автомат с \(n\) счётчиками
  \((\A, z_1^0, z_2^0, \ldots, z_n^0)\).  Каноническими уравнениями называется система
  \ref{eq:canonical}
  \begin{equation}
    \label{eq:canonical}
    \begin{cases}
      q(0) = q_0 \\
      z_1(0) = z_1^0 \\
      z_2(0) = z_2^0 \\
      \ldots \\
      z_n(0) = z_n^0 \\
      q(t + 1) = \varphi(q(t), a(t)) \\
      z_1(t + 1) = z_1(t) + \psi_1(q(t), a(t)) \\
      z_2(t + 1) = z_2(t) + \psi_2(q(t), a(t)) \\
      \ldots \\
      z_n(t + 1) = z_n(t) + \psi_n(q(t), a(t))
    \end{cases}
  \end{equation}
  где
  \begin{align*}
    & t \in \N_0 \\
    & a(t) = (sign(z_1(t)), sign(z_2(t)), \ldots,
      sign(z_n(t))) \\
    & sign(x) =
      \begin{cases}
        -1, &x \in (-\infty; 0) \\
        0, &x = 0 \\
        1, &x \in (0; \infty)
      \end{cases} \\
  \end{align*}
\end{definition}

\begin{definition}
  \label{def:behaviour}
  Пусть у нас есть инициализированный автомат с \(n\) счётчиками
  \((\A, z_1^0, z_2^0, \ldots, z_n^0)\).
  \begin{itemize}
  \item Если существует момент времени \(t'\), такое что \(q(t') \in Q_f\), тогда поведением
    инициализированного автомата с \(n\) счётчиками называется конечная последовательность:
    \begin{align*}
      & (q(0), z_1(0), z_2(0), \ldots, z_n(0)) \\
      & (q(1), z_1(1), z_2(1), \ldots, z_n(1)) \\
      & \ldots, \\
      & (q(t'), z_1(t'), z_2(t'), \ldots, z_n(t'))
    \end{align*}
    В этом случае говорится инициализированный автомат с \(n\) счётчиками остановится.
  \item Если не существует момент времени \(t'\), такое что \(q(t') \in Q_f\), тогда поведением
    инициализированного автомата с \(n\) счётчиками называется бесконечная последовательность:
    \begin{align*}
      & (q(0), z_1(0), z_2(0), \ldots, z_n(0)) \\
      & (q(1), z_1(1), z_2(1), \ldots, z_n(1)) \\
      & \ldots, \\
      & (q(t), z_1(t), z_2(t), \ldots, z_n(t')) \\
      & \ldots
    \end{align*}
    В этом случае говорится инициализированный автомат с \(n\) счётчиками не остановится.
  \end{itemize}
\end{definition}

Автомат с \(n\) счётчиками можно рассмотреть как автомат соединенные с \(n\) внешними счётчиками,
каждый который может хранить неотрицательное число.  Автомат может видеть только то что, каждый
счётчик равно нулю или нет.  Каждый момент времени автомат может менять значения счётчика не более
чем на одну единицу, при этом значения счётчиков всегда должен остаться неотрицательным.
Ограничение \ref{eq:constraint} как раз таки обеспечивает неотрицательность счётчиков.

Рассмотрим автомат с двумя счётчиками.

\begin{definition}
  \label{def:manoeuvre}
  Пусть у нас есть инициализированный автомат с двумя счётчиками.  Конечным манёвром называется
  поведение автомата от момента времени \(t_1\) до \(t_2\):
  \begin{align*}
    & (q(t_1), z_1(t_1), z_2(t_1)), \\
    & (q(t_1 + 1), z_1(t_1 + 1), z_2(t_1 + 1)), \\
    & \ldots, \\
    & (q(t_2), z_1(t_2), z_2(t_2))
  \end{align*}
  если выполняется следующая условия:
  \begin{equation*}
    \begin{cases}
      z_1(t_1) = 0 \vee z_2(t_1) = 0 \\
      \forall t (t_1 \leq t < t_2 \Rightarrow q(t) \notin Q_f) \\
      \forall t (t_1 < t < t_2 \Rightarrow (z_1(t) \ne 0 \wedge z_2(t) \ne 0)) \\
      z_1(t_2) = 0 \vee z_2(t_2) = 0
    \end{cases}
  \end{equation*}
\end{definition}

\begin{definition}
  \label{def:notfull_manoeuvre}
  Пусть у нас есть инициализированный автомат с двумя счётчиками.  Непольным манёвром называется
  поведение автомата от момента времени \(t_1\) до \(t_2\):
  \begin{align*}
    & (q(t_1), z_1(t_1), z_2(t_1)), \\
    & (q(t_1 + 1), z_1(t_1 + 1), z_2(t_1 + 1)), \\
    & \ldots, \\
    & (q(t_2), z_1(t_2), z_2(t_2))
  \end{align*}
  если выполняется следующая условия:
  \begin{equation*}
    \begin{cases}
      z_1(t_1) = 0 \vee z_2(t_1) = 0 \\
      \forall t (t_1 < t \leq t_2 \Rightarrow (z_1(t) \ne 0 \wedge z_2(t) \ne 0)) \\
      q(t_2) \in Q_f
    \end{cases}
  \end{equation*}
\end{definition}

\begin{definition}
  \label{def:infinity_manoeuvre}
  Пусть у нас есть инициализированный автомат с двумя счётчиками.  Бесконечным манёвром называется
  поведение автомата от момента времени \(t_1\):
  \begin{align*}
    & (q(t_1), z_1(t_1), z_2(t_1)), \\
    & (q(t_1 + 1), z_1(t_1 + 1), z_2(t_1 + 1)), \\
    & \ldots
  \end{align*}
  если выполняется один из следующих условий:
  \begin{equation*}
    \begin{cases}
      z_1(t_1) = 0 \vee z_2(t_1) = 0\\
      \forall t (t_1 < t \Rightarrow (z_1(t) \ne 0 \wedge z_2(t) \ne 0 \wedge q(t) \notin Q_f))
    \end{cases}
  \end{equation*}
\end{definition}

Мы рассмотрим вычислимость частично определенных функции из \(m\) переменных, то есть функции,
которые имеет вид: \(f: M \rightarrow \N_0\), где \(M \subseteq \N_0^m\).  Будем
записать \(f(x_1, \ldots, x_m) = \lambda\), если \(f\) в точке \((x_1, \ldots, x_m)\) неопределено.

\begin{definition}
  \label{def:computability}
  Будем говорить что автомат \(\A\) с \(n\) счётчиками вычисляет функция \(m\)-переменных
  \(f_{\A}: M \rightarrow \N_0\) (где \(M \subseteq \N_0^m\) и \(m \leq n\)), если:
  \begin{itemize}
  \item \(f_{\A}(x_1, x_2, \ldots, x_m) = y\) и инициализированный автомат
    \((\A, x_1, x_2, \ldots, x_m, 0, \ldots, 0)\) остановится, причем в момент остановки \(t'\)
    значения одного счётчика равно \(y\), а всех остальных равен \(0\)
  \item \(f_{\A}(x_1, x_2, \ldots, x_m) = \lambda\) и инициализированный автомат с \(n\) счётчиками
    \((\A, x_1, x_2, \ldots, x_m, 0, \ldots, 0)\) остановится, причем в момент остановки \(t'\)
    существует более чем один ненулевой счётчик.
  \item \(f_{\A}(x_1, x_2, \ldots, x_m) = \lambda\) и инициализированный автомат с \(n\) счётчиками
    \((\A, x_1, x_2, \ldots, x_m, 0, \ldots, 0)\) не остановится
  \end{itemize}
\end{definition}

Мы рассмотрим только частично определенных функции одной переменной.  Обозначим через \(J_n\)
множество всех частично определенных функции одной переменной, которые вычислимы через автоматы с
\(n\) счётчиками.  Очевидно что для любого \(n\) верно \(J_n \subseteq J_{n + 1}\).

Обозначим через \(\F\) все частично определенных функции одной переменной.

Множество значений функции \(f \in \F\) обозначим через \(Im(f)\).

\begin{definition}
  \label{def:switcher}
  Пусть \(g \in \F\).  \(g\) называется переключательной функцией, если
  \(\left|Im(g)\right| < \infty\).
\end{definition}

Обозначим через \(\G\) множество всех переключательных функции.

\begin{definition}
  \label{def:switcher_rang}
  Пусть \(g \in \G\).  \(\left|Im(g)\right|\) называется рангом функции \(g\).
\end{definition}

\begin{definition}
  \label{def:function_with_switcher}
  Пару \((f, g)\) называется функцию с переключателем, если \(f \in \F, g \in \G\) и
  \(\forall x [f(x) = \lambda \Leftrightarrow g(x) = \lambda]\).
\end{definition}

\begin{definition}
  \label{def:generalized_superposition}
  Пусть \(n \in \N\), \((f_0, g_0)\), \((f_1, g_1)\), \((f_2, g_2)\), \ldots,
  \((f_n, g_n)\) --- функции с переключателями и \(E(g_0) = \{k_1, k_2, \ldots, k_n\}\).
  Тогда определим оператор обобщенной суперпозиции \(S_n\) следующим образом: если
  \((f, g) = S_n[(f_0, g_0), (f_1, g_1), (f_2, g_2), \ldots (f_n,
  g_n)]\), то \(f\) и \(g\) имеет вид
  \begin{align}
    \label{eq:generalized_superposition}
    & f(x) =
      \begin{cases}
        f_1(f_0(x)), & g_0(x) = k_1 \\
        f_2(f_0(x)), & g_0(x) = k_2 \\
        \ldots \\
        f_n(f_0(x)), & g_0(x) = k_n
      \end{cases} \\
    & g(x) =
      \begin{cases}
        g_1(f_0(x)), & g_0(x) = k_1 \\
        g_2(f_0(x)), & g_0(x) = k_2 \\
        \ldots \\
        g_n(f_0(x)), & g_0(x) = k_n
      \end{cases}
  \end{align}
  При этом для любого \(x \in \N_0\) если \(f_0(x) = \lambda\) (соответственно
  \(g_0(x) = \lambda\)), то \(f(x) = \lambda\) и \(g(x) = \lambda\)
\end{definition}

Прежде чем определять следующий оператор введем некоторые обозначения:
\begin{itemize}
\item \(f^k(x)\) --- это \(k\) раз применения функция \(f\) на \(x \in \N_0\).  Если для \(x\)
  существует \(l \in \overline{1, k}\), такая что \(f^l(x) = \lambda\), то \(f^k(x) = \lambda\).
\item Пусть \((f, g)\) --- функция с переключателем.  Тогда для любого \(a \in \N_0\)
  определим следующие множества:
  \begin{align*}
    & \Delta_0(a) = \{x \in \N_0 | g(x) = a\} \\
    & \Delta_{k + 1}(a) = \{x \in \Delta_{k} | g(f^{k + 1}(x)) = a\},\ \text{где}\ k \geq 0 \\
    & X_0(a) = \N_0 \setminus \Delta_0(a) \\
    & X_{k + 1}(a) = \Delta_{k}(a) \setminus \Delta_{k + 1}(a),\ \text{где}\ k \geq 0 \\
    & X_{\infty}(a) = \N_0 \setminus \bigcup_{k \geq 0} X_k(a)
  \end{align*}
\end{itemize}

\begin{definition}
  \label{def:special_recursion}
  Пусть \((f_0, g_0)\) --- функция с переключателем Тогда определим оператор специальной
  рекурсии \(R\) следующим образом: Если \((f, g) = R_a[(f_0, g_0)]\), то \(f\) и
  \(g\) имеет вид:
  \begin{align}
    \label{eq:generalized_superposition}
    & f(x) =
      \begin{cases}
        f^{k + 1}_0(x), & x \in X_k(a) \\
        \lambda, & x \in X_{\infty}(a)
      \end{cases} \\
    & g(x) =
      \begin{cases}
        g_0(x), & x \in X_0(a) \\
        g_0(f_0^k(x)), & x \in X_k(a), k \geq 1 \\
        \lambda, & x \in X_{\infty}(a)
      \end{cases}
  \end{align}
  При этом для любого \(x \in \N_0\) если \(f_0^l(x) = \lambda\) (где \(1 \leq l \leq k\)), то
  \(f(x) = \lambda\) и \(g(x) = \lambda\)
\end{definition}

\begin{definition}
  \label{def:periodic}
  Функцию \(f \in \F\) называется периодичным, если существует \(T \in \N\) и \(x_0 \in \N_0\),
  такое что для любого \(x > x_0\) и для любого \(k \in \N_0\) верно \(f(x) = f(x + kT)\).
\end{definition}

Аналогично определяется периодическая функция с целочисленными значениями.

Обозначим наимеший период функции \(g\) через \(T_{g}\).

Обозначим множество всех периодичных функции через \(\G_p\).  Очевидно что
\(\G_p \subset \G\).

\begin{definition}
  \label{def:pseudoperiodic}
  Функцию \(f \in \F\) называется псевдопериодичным, если существует \(x_0 \in \N_0\), такое что для
  любого \(x > x_0\) существует \(T \in \N\), такое что для любого \(k \in \N_0\) верно
  \(f(x) = f(x + kT)\).
\end{definition}

Обозначим множество всех псевдоперидочных функции через \(\F_p\).  Очевидно что
\(\G_p \subset \F_p\).

\begin{definition}
  \label{def:manoeuvre_function}
  Функцию \(f \in \F\) называется функцию маневра если она имеет один из следующих видов:
  \begin{align}
    \label{eq:manoeuvre_function}
    & f(x) =
      \begin{cases}
        C_0, & x = 0 \\
        C_1, & x = 1 \\
        \ldots \\
        C_k, & x = k \\
        \frac{a x + b(x)}{d}, & x > k
      \end{cases} \\
    \label{eq:manoeuvre_function_nd}
    & f(x) =
      \begin{cases}
        C_0, & x = 0 \\
        C_1, & x = 1 \\
        \ldots \\
        C_k, & x = k \\
        \lambda, & x > k
      \end{cases}
  \end{align}
  где \(C_0, C_1, \ldots C_k \in \N_0 \cup \{\lambda\}\), \(b(x)\) --- периодическая функция с
  целочисленными значениями, которая имеет предпериод \(k\) и период \(d\).
  Причем \(b(x)\) такая, что \(\frac{a x + b(x)}{d} \in \N_0\)
  для всех \(x \in \N_0\).  Число \(d\) называем шагом функции
  маневра и обозначим через \(d_{f}\).  А число \(k\) предманевр функции маневра и обозначим через
  \(k_f\).
\end{definition}

Обозначим множество всех функции маневра через \(\F_m\).

\begin{definition}
  \label{def:manoeuvre_function_switcher}
  Функцию с переключателем \((f, g)\) называем функция маневра с переключателем, если
  выполняется следующие условия: \(f \in \F_m\), \(g \in \G_p\) и \(d_f = T_{g}\).
\end{definition}

Обозначим множество всех функции маневра с переключателем через \(\M_m\).

\begin{definition}
  \label{def:generalized_manoeuvre_function_with_switcher}
  Определим обобщенную функцию маневра с переключателем через индуктивное определение:
  \begin{enumerate}
  \item Любая функция маневра с переключателем это обобщенная функция маневра с переключателем.
  \item Для любого \(n \in \N\) и \(m \in \N_0\) если \((f_0, g_0)\), \((f_1, g_1)\),
    \((f_2, g_2)\), \ldots, \((f_n, g_n)\) является обобщенной функции маневра с
    переключателем, то функции
    \((f', g') = S_n[(f_0, g_0), (f_1, g_1), \ldots, (f_n, g_n)]\) и
    \((f'', g'') = R_a[(f_0, g_0)]\) тоже является обобщенной функции маневра с
    переключателем.
  \end{enumerate}
\end{definition}

Обозначим множество всех обобщенных функции маневра с переключателем через \(\M_2\).

\begin{definition}
  \label{def:generalized_manoeuvre_function}
  Функцию \(f\) называем обобщенная функция маневра, если существует \(g \in \G\) такое что
  \((f, g) \in \M_2\).
\end{definition}

Обозначим множество всех обобщенных функции маневра через \(\F_2\).

Определим еще одно понятия для доказательства теорем.

\begin{definition}
  \label{def:graph}
  Пусть дано ориентированный нагруженный граф \(G = (V, E)\), где петли разрешены, но кратные
  ребри (и кратные петли) не разрешены и дано множество \(\M \subseteq \F \times \G\).
  Еще запрещаем существование вершин 
  Выделим некоторую вершину этого графа \(v_s\), которую будем называть стартовая вершина.  Еще
  выделим некоторое подмножество множество вершин этого графа \(V_f\), которому не входить стартовая
  вершина \(v_s\), то есть \(V_f \subseteq V \setminus \{v_s\}\).  Множество \(V_f\) будем называть
  множество финальных вершин.  Пометим все не финальные вершины графа \(v \in V \setminus V_f\)
  меткой \((f_v, g_v)\), где \((f_v, g_v) \in \M\). Причем полустепень исхода вершины
  \(v\) совпадает с рангом функции \(g\).  Каждое ребро исходящий из \(v\) пометим через
  значения функции \(g_v\), причем одно значения не должен повторятся.  При этом должен
  выполнятся условия, что для любой вершины все заходящие в эту вершины ребра должны быть
  одинаковыми и ребра заходящие в двух разных вершин может иметь одинаковые метки тогда и только
  тогда, когда эти вершины имеет одинаковые метки.  Называем полученный граф вычислительным графом
  над множеством \(\M\).
\end{definition}

Вычислительный граф \(G\) принимает как вход некоторое \(x \in \N_0\) и дает другое число используя
следующий алгоритм (пусть \(v_a\) --- активная вершина и \(y\) --- текущая значения):
\begin{enumerate}
\item \(v_a := v_s\), \(y := x\).
\item Если \(v_a \in V_f\), алгоритм закончится и в качестве ответа даем \(y\), если нет переходим
  на шаг 3.
\item Находим \(v'\), такое что метка \((v, v')\) равно \(g_{v_a}(y)\) и делаем
  \(y := f_{v_a}(y)\), \(v_a := v'\), и переходим на шаг 2.
\end{enumerate}

Если алгоритм при некотором \(x \in \N_0\) не закончится или в каком-то шаге функции даёт
неопределённость, то считаем что вычислительный граф \(G\) даёт неопределённость как ответ.

Последовательность вершин \(v_1, v_2, \ldots, v_n\), которые были активны называем путь вычисления
\(x\).

\begin{definition}
  \label{def:normal_graph}
  Пусть \(G\) вычислительный граф над множеством \(\M\).  Если в графе все вершины имеет
  полустепень захода не более чем 2 и каждая вершина, которая имеет полустепень захода 2, является
  вершиной простого цикла причем только одного:
  Тогда граф \(G\) называется нормальным вычислительныи графом.
\end{definition}

\begin{definition}
  \label{def:graph_function}
  Вычислительный граф \(G\) над множеством \(\M\) вычисляет функцию \(f_G\), если \(G\) при
  входном значении \(x\) даёт выходное значения \(f(x)\).
\end{definition}

Определим некоторые операции над вычислительными графами.

\begin{definition}
  \label{def:duplicate}
  Пусть дано вычислительный граф \(G\) над множеством \(\M\) и его вершина
  \(v \in V \setminus V_f\).  Обозначим через \(v_1, v_2, \ldots, v_n\) вершины которые не совпадает
  с \(v\) и при этом от них исходит ребра, которые заходит в вершину \(v\).  Тогда определим
  операцию дублирования над парой \((G, v)\) следующим образом:
  \begin{enumerate}
  \item Добавим новую вершину \(v^*\) к графу \(G\) и пометим его таким же меткой
    \((f_v, g_v)\), как у \(v\).
  \item Дальше есть два случая:
    \begin{itemize}
    \item Исходящее ребро от \(v\) с меткой \(a\) не является петлёй и заходить к вершине
      \(v'\). Тогда исходящее ребро от \(v^*\) с меткой \(a\) заходить к вершине \(v'\)
    \item Исходящее ребро от \(v\) с меткой \(a\) является петлёй.  Тогда исходящее ребро от \(v^*\)
      с меткой \(a\) тоже будет петлёй
    \end{itemize}
  \item Удалим ребро исходящий из \(v_1\) и заходящий к \(v\) и проводим эту ребру от
    \(v_1\) к \(v^*\) и пометим той же меткой
  \end{enumerate}
\end{definition}

\begin{definition}
  \label{def:unite}
  Пусть дано нормальный вычислительный граф \(G\) над множеством \(\M\) и его вершина
  \(v \in V \setminus V_f\).  Пусть из вершины \(v\) исходит ребра, которые заходить к вершинам
  \(v'_1, v'_2, \ldots, v'_n\) и имеет метки \(k_1, k_2, \ldots, k_n\) соответственно. При этом
  \(v'_1, v'_2, ..., v'_n\) не имеет петли.  Тогда определим операцию объединение над парой
  \((G, v)\) следующим образом:
  \begin{enumerate}
  \item Добавим вершину \(v^*\), которая имеет метку равную
    \(S_n[(f_v, g_v), (f_1, g_1), (f_2, g_2), \ldots, (f_n, g_n)]\).  Здесь
    \((f_i, g_i)\) равно:
    \begin{itemize}
    \item метку вершины \(v'_i\), если \(v'_i \in V \setminus V_f\)
    \item \((I, Const_{k_i})\), если \(v'_i \in V_f\).
    \end{itemize}
  \item Проводим ребро с меткой \(a\) исходящий от \(v^*\) к вершине, которому заходить ребро с той
    же меткой исходящий от вершин \(v'_1, v'_2, \ldots, v'_n\)
  \item Удалим вершины \(v, v'_1, v'_2, \ldots, v'_n\)
  \item Проводим все ребра которые заходили в вершину \(v\), к вершину \(v^*\)
  \end{enumerate}
\end{definition}

\begin{definition}
  \label{def:eliminate_loop}
  Пусть дано нормальный вычислительный граф \(G\) над множеством \(\M\) и его вершина
  \(v \in V \setminus V_f\).  Пусть вершина \(v\) имеет петлю по метке \(a\). Тогда операцию
  устранения петли определим над парой \((G, v)\) так:
  \begin{enumerate}
  \item Меняем метку вершины \(v\) на \(R_a[(f_v, g_v)]\)
  \item Удалим петлю с меткой \(a\)
  \end{enumerate}
\end{definition}

\clearpage

\section{Классические результаты}

\begin{theorem}
  \label{theor:one_counter}
  \(J_1\) состоит из периодических функции и функции следующего вида:
  \begin{equation*}
    f(x) =
    \begin{cases}
      C_0, & x = 0 \\
      C_1, & x = 1 \\
      \ldots \\
      C_k, & x = k \\
      x + c, & x > k
    \end{cases}
  \end{equation*}
  где \(C_0, C_1, \ldots, C_k \in \N_0 \cup \{\lambda\}\) и \(k, c \in \N_0\).
\end{theorem}

\begin{theorem}
  \label{theor:three_counter}
  \(J_3\) совпадаеть с классом частично рекурсивных функции от одной переменной.
\end{theorem}

\begin{theorem}
  \label{theor:two_counter_special}
  Пусть у нас есть кодировка \(x \mapsto 2^x\).  В таком кодировке любая частично рекурсивная
  функция вычислима на автоматах с двумя счётчиками.
\end{theorem}

\clearpage

\section{Основные результаты}

\begin{theorem}
  \label{computable_functions}
  \(\F_2 = J_2\).
\end{theorem}

\begin{theorem}
  \label{expression}
  Любая функция \(f\) из \(J_2\) имеет вид:
  \begin{equation}
    \label{eq:j2}
    f(x) = \frac{a(x) \cdot x + b(x)}{d(x)}
  \end{equation}
  где \(a(x)\), \(b(x)\) и \(d(x)\) псевдопериодическые функции.
\end{theorem}

\begin{consequence}
  Функции \(f_1(x) = 2^x\) и \(f_2(x) = \lfloor \log_2 x \rfloor\) не вычислимы через автоматы
  с двумя счётчиками.
\end{consequence}

\clearpage

\section{Леммы и доказательства}

\begin{lemma}
  \label{lemma:manoeuvre}
  Пусть дано автомат с 2 счётчиками \(\A\) с \(N\) состояниями.
  Нумеруем все состояния автомата: \(q_0, q_1, q_2, \ldots, q_{N - 1}\).
  \(q_0\) --- начальная состония.
  Тогда существует такое функция маневра с переключателем
  \((f, g) \in \M_m\), такое что для любого значения \(x\) верно:
  \begin{enumerate}
  \item Если инициализированный автомат \((\A, x, 0)\) совершает конечный маневр и этот маневр
    закончится момент времени \(t'\) и если при этом \(z_1(t') = 0\), тогда \(z_2(t') = f(x)\),
    \(q(t') = q_{g(x)}\)
  \item Если инициализированный автомат \((\A, x, 0)\) совершает конечный маневр и этот маневр
    закончится момент времени \(t'\) и если при этом \(z_2(t') = 0\), тогда \(z_1(t') = f(x)\),
    \(q(t') = q_{g(x)}\)
  \item Если инициализированный автомат \((\A, x, 0)\) совершает непольный маневр, тогда
    \(f(x) = \lambda\), \(g(x) = \lambda\)
  \item Если инициализированный автомат \((\A, x, 0)\) совершает бесконечный маневр, тогда
    \(f(x) = \lambda\), \(g(x) = \lambda\)
  \end{enumerate}
\end{lemma}

\begin{proof}
  Пусть у нас есть автомат с двумя счётчиками \(\A\) и количество состоянии этого автоматота \(N\).
  Заметим что нам достаточно доказать утверждения начиная с некоторого \(k\),
  так как в выражениях \ref{eq:manoeuvre_function}
  и \ref{eq:manoeuvre_function_nd} значения констант \(C_0, C_1,
  \ldots, C_k\) можно задать как любое число (или неопределённость, то есть \(\lambda\)).
  И в предпериоде \(g\) тоже может принимать любые значения.

  Рассмотрим два случая:
  \begin{itemize}
  \item Существует \(k\), такое что для любого \(x > k\) если первый маневр автомата \((\A, x, 0)\)
    закончится момент времени \(t'\), то \(z_1(t') > 0\).
    Тогда для любого \(x > k\) рассмотрим конечную последовательность входов автомата \((\A, x, 0)\):
    \begin{align*}
      & (a_1(0), a_2(0)) \\
      & (a_1(1), a_2(1)) \\
      & \ldots \\
      & (a_1(t'), a_2(t'))
    \end{align*}
    где \(a_i(t) = sign(z_i(t))\), для \(i \in \{1, 2\}, 0 \leq t \leq t'\).
    Для всех \(0 \leq t \leq t'\), верно \(z_1(t') > 0\), поскольку если это было не так,
    то существует момент времени \(t''\), такое что \(0 < t'' < t'\) и \(z_1(t'') = 0\).
    Но это означает что первый маневр закончился бы момент времени \(t'' < t'\).
    Значить \(a_1(t) = 1\), для всех \(0 \leq t \leq t'\)
    Также для всех \(0 < t < t'\), верно \(z_2(t) > 0\) (доказывается аналогично для случая \(z_1\)).
    Дальше есть два варианта:
    \begin{enumerate}
    \item \(z_2(t') \ne 0\), значить маневр был непольным
    \item \(z_2(t') = 0\), значить маневр был конечным
    \end{enumerate}
    Обоих случаях ни \(t'\), ни входные символи не зависит от \(x\).
    Значить и последовательность состоянии, и как следствия последовательность выходных символов не
    зависит от \(x\).
    Значить:
    \begin{enumerate}
    \item В случае \(z_2(t') \ne 0\), для любого \(x > k\), \(f(x) = \lambda\) и
      \(g(x) = \lambda\).
    \item В случае \(z_2(t') = 0\), для любого \(x > k\), \(z_1(t') = z_1^0 + c\) где \(c \in \Z\).
      Тогда \(f(x) = x + c = \frac{1 \cdot x + c}{1}\), \(g(x)\) равно номеру состоянии \(q(t')\).
    \end{enumerate}
  \item Для любого \(x_0\), существует такое \(x'\), такое что первый маневр \((A, x', 0)\)
    закончится в момент времени \(t'\) и \(z_1(t') = 0\).
    Пусть \(x\) такое число, что \(x \geq N + 1\) и в конце первого маневра \((A, x, 0)\) значения
    первого счётчика равно \(0\).
    Тогда \(z_1^0 = x > N + 1 \Rightarrow t' > N + 1\).
    И по определению конечного маневра верно следующее:
    \begin{equation*}
      0 < t < t' \Rightarrow (z_1(t) > 0 \wedge z_2(t) > 0) \Rightarrow a_1(t) = 1 \wedge a_2(t) = 1
    \end{equation*}
    Тогда существует моменты времени \(0 < i < j < t'\), такое что \(q(i) = q(j)\), поскольку
    существует как минимум \(N + 1\) момент времени между \(0\) и \(t'\). Но количество состоянии
    автомата \((\A)\) равно \(N\). Обозначим \(T = j - i\).
    Тогда:
    \begin{align*}
      & q(i) = q(i + T) \\
      & a_1(i) = a_1(i + T) \\
      & a_2(i) = a_2(i + T) \\
      & q(i + 1) = \varphi(q(i), a_1(i), a_2(i))
        = \varphi(q(i + T), a_1(i + T), a_2(i + T)) = q(i + T + 1) \\
      & j + 1 < t' \Rightarrow a_1(i + 1)
        = sign(z_1(i + 1)) = sign(z_1(i + T + 1)) = a_1(i + T + 1) \\
      & j + 1 < t' \Rightarrow a_2(i + 1)
        = sign(z_2(i + 1)) = sign(z_2(i + T + 1)) = a_2(i + T + 1) \\
      & \ldots \\
      & j + \delta < t' \Rightarrow
        q(i + \delta) = \varphi(q(i + \delta - 1), a_1(i + \delta - 1), a_2(i + \delta - 1)) \\
      & = \varphi(q(i + T + \delta - 1), a_1(i + T + \delta - 1), a_2(i + T + \delta - 1))
        = q(i + T + \delta) \\
      & j + \delta < t' \Rightarrow a_1(i + \delta)
        = sign(z_1(i + \delta)) = sign(z_1(i + T + \delta)) = a_1(i + T + \delta) \\
      & j + \delta < t' \Rightarrow a_2(i + \delta)
        = sign(z_2(i + \delta)) = sign(z_2(i + T + \delta)) = a_2(i + T + \delta) \\
     \end{align*}
     То есть если для любого \(t \geq 0\)
  \end{itemize}
\end{proof}

Тогда каждым состоянию автомата \(\A\) можно сопоставить два функцию с переключателем.

Выше мы рассмотрели первый маневр автомата \(\A\) при начальном состоянии \(q_0\).
Это маневр при состоянии \(q_0\). Можно рассмотреть другие манервры, которых реализует автомат
находясь в другом состоянии при одном нулевом счётчика.
Таким образом в общем случае поведение автомата это переключающие между собой маневры которые
зависит от начальных значениях счётчиков.

\begin{lemma}
  \label{lemma:automata_to_graph}
  Пусть дано автомат \(\A\) и пусть это автомат вычисляет функция
  \(f_{\A} : \N_0 \rightarrow \N_0\).  Тогда существует вычислительный граф над множеством
  \(\M_m\), который вычисляет ту же функцию \(f_{\A}\).
\end{lemma}

\begin{proof}
  Пусть автомат \(\A\) имеет \(N\) состоянии. Тогда в графе \(G\) будет \(2 N\) вершин и обозначим
  их как \(v_0^1, v_0^2, v_1^1, v_1^2, \ldots, v_{N-1}^1, v_{N-1}^2\).
  И как метки вершины \(v_i^1\), где \(0 \leq i < N\), берем функцией с переключателем
  \((f_i^1, g_i^1)\), где \((f_i^1, g_i^1)\) функция маневра с переключателем которая соответствует
  состоянии \(q_0\) при нулевом значении второго счётчика.
  Аналогично пометим вершины \(v_i^2\).
  И проводим
\end{proof}

\begin{lemma}
  \label{lemma:graph_to_automata}
  Пусть дано вычислительный граф \(G\) над множеством \(\M_m\) и пусть это граф вычисляет функция
  \(f_G : \N_0 \rightarrow \N_0\).  Тогда существует автомат с двумя счётчиками, который
  вычисляет ту же функцию \(f_{G}\).
\end{lemma}

\begin{lemma}
  \label{lemma:duplicate_closure}
  Пусть дано вычислительный граф \(G\) над множеством \(\M \subseteq \F \times \G\), который
  вычисляет функцию \(f_G: \N_0 \rightarrow \N_0\) и пусть \(v \in V \setminus V_f\).  Тогда граф
  \(G^*\), полученное применением операции дублирования над \((G, v)\) тоже вычисляет функцию
  \(f_G\).
\end{lemma}

\begin{proof}
  Пусть \(v^*\) это добавленная вершина к \(G\) через операцию дублирования.
  И пусть \(v_1\) вершина, такое что исходящее от неё ребро заходить в \(v\) в графе \(G\) и
  заходить в \(v^*\) в графе \(G^*\)

  Пусть нам дано \(x \in \N_0\).
  Есть три случая:
  \begin{enumerate}
  \item Если путь вычисления \(x\) в графа \(G\) не проходит через вершину \(v\),
    то она совпадает путьем вычисления \(x\) в графе \(G^*\).
    Потому что операция дублирования изменяет только ребро заходящий в \(v\)
    Таким образом они даёт одинаковый ответ.
  \item Пусть тепер путь вычисления \(x\) в графе \(G\) проходить через \(v\) но не проходить через
    вершину \(v_1\).
    Тогда путь вычисления \(x\) в графе \(G^*\) совпадает с путьем вычисления \(x\) в графе
    \(G\). Потому что ребро исходящие от вершин, которые отличаются от \(v_1\) заходить в ту же
    вершину \(v\). Таким образом в этом случае тоже они дают одинаковый ответ.
  \item Путь вычисления \(x\) в графе \(G\) проходить через вершины \(v\) и \(v_1\). Тогда пути
    вычисления \(x\) различается только тех местах где находится вершина \(v\).
    \begin{align*}
      & G: w_0, w_1, \ldots, v, \ldots \\
      & G^*: w_0, w_1, \ldots, v^*, \ldots
    \end{align*}
    Но поскольку они имеет одинаковые метки, при вычислении, они текущая значения преобразует
    одинаково, и они передает значения либо на один и тот же вершину (когда ребро не петля),
    либо передает на самих себя (когда ребро является петлей). Но когда они передают на самих они
    опять будут одинаково обрабативать это значения.
  \end{enumerate}
\end{proof}

\begin{lemma}
  \label{lemma:graph_to_normal_graph}
  Пусть дано вычислительный граф \(G\) над множеством \(\M \subseteq \F \times \G\), который
  вычисляет функцию \(f_G: \N_0 \rightarrow \N_0\).  Тогда можно построить нормальный вычислительный
  граф \(G^*\), который тоже вычисляет функцию \(f_G\).
\end{lemma}

\begin{proof}

\end{proof}

\begin{lemma}
  \label{lemma:unite_closure}
  Пусть дано норамальный вычислительный граф \(G\) над множеством \(\M \subseteq \F \times \G\),
  который вычисляет функцию \(f_G: \N_0 \rightarrow \N_0\) и пусть \(v \in V \setminus V_f\).  Тогда
  граф \(G^*\), полученное применением операции объединение над \((G, v)\) тоже является нормальным
  вычислительным графом и тоже вычисляет функцию \(f_G\).
\end{lemma}

\begin{lemma}
  \label{lemma:eliminate_loop_closure}
  Пусть дано норамальный вычислительный граф \(G\) над множеством \(\M \subseteq \F \times \G\),
  который вычисляет функцию \(f_G: \N_0 \rightarrow \N_0\) и пусть \(v \in V \setminus V_f\).  Тогда
  граф \(G^*\), полученное применением операции устранения петли над \((G, v)\) тоже является
  нормальным вычислительным графом и тоже вычисляет функцию \(f_G\).
\end{lemma}

\begin{lemma}
  \label{lemma:graph_to_function}
  Пусть дано вычислительный граф \(G\) над множеством \(\M_m\). Тогда функция \(f_G\)
  которая вычисляет граф является обобщенная функция маневра, то есть \(f_G \in \F_2\)
\end{lemma}

\begin{lemma}
  \label{lemma:function_to_graph}
  Пусть дано обобщенная функция маневра \(f\). Тогда можно построить вычислительный граф
  \(G_f\) над множеством \(\M_m\), который вычисляет функцию \(f\).
\end{lemma}

\begin{theorem}
  \label{computable_functions}
  \(\F_2 = J_2\).
\end{theorem}

\begin{theorem}
  \label{expression}
  Любая функция \(f\) из \(J_2\) имеет вид:
  \begin{equation}
    \label{eq:j2}
    f(x) = \frac{a(x) \cdot x + b(x)}{d(x)}
  \end{equation}
  где \(a(x)\), \(b(x)\) и \(d(x)\) псевдопериодическые функции.
\end{theorem}

\clearpage

\section{Заключения}

\clearpage

\begin{thebibliography}{}
\bibitem{litautomatacounters} Кузьмин Е.В., Соколов В.А.  \textit{Автоматные счетчиковые
    машины}. Ярославль, 2012.
\bibitem{litautomatatheory} Кудрявцев В.Б., Алешин С.В., Подколзин А.С.  \textit{Введение в теорию
    автоматов}. Наука, 1985.
\bibitem{litautomatalanguages} Д. Хопкрофт, Р. Мотвани, Д. Ульман \textit{Введение в теорию
    автоматов, языков и вычислений}. 2-е изд. : Пер. с англ. --- Москва, Издательский дом
  ``Вильямс'', 2002.
\end{thebibliography}

\end{document}