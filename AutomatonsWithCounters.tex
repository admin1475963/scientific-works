\documentclass[14pt, a4paper, oneside]{article}

\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{fontspec}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{amsthm}
\usepackage{indentfirst}
\usepackage[left=3cm,right=1cm,
    top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}

\setmainfont{Heuristica}

\newtheorem{definition}{Определение}
\newtheorem{theorem}{Теорема}[section]
\newtheorem{consequence}{Следствие}[section]
\newtheorem{note}{Замечание}
\newtheorem{lemma}{Лемма}
\newtheorem{hypothesis}{Гипотеза}
\renewcommand{\thetheorem}{\arabic{theorem}}
\renewcommand{\theconsequence}{\arabic{consequence}}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\F}{\mathcal{F}}
\newcommand{\G}{\mathcal{G}}
\newcommand{\M}{\mathcal{M}}

\begin{document}

\thispagestyle{empty}

\begin{center}
  \Large
  МОСКОВСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ \\
  \bigskip
  имени М.В.Ломоносова \\
  \bigskip
  Филиал в г.Ташкенте \\
  \bigskip
  Факультет Прикладной Математики и Информатики \\
  \bigskip
  \hrule
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \textbf{Курсовая работа} \\
  \bigskip
  \textbf{Функции вычислимые через автоматы с двумя счётчиками} \\
  \bigskip
  \bigskip
  \Large
  Подготовил: \\
  Студент третьего курса факультета ПМиИ \\
  Илхомов Мухаммад Муроджон угли \\
  \bigskip
  \bigskip
  Научный руководитель: \\
  Волков Николай Юрьевич \\
  \bigskip
  \hrule
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \textbf{2022}
\end{center}

\clearpage

\linespread{1.25}

\normalsize
\tableofcontents

\clearpage

\section{Введение}

В данной работе изучается одноместные частичные функции вычислимые через автоматы с двумя
счётчиками в естественном кодировке чисел. Уже давно известно что при специальном кодировке
автомат с двумя счётчиками может моделировать автомат с тремя счётчиками и как следствия может
вычислять любые одноместные функции вычислимые по Тьюрингу. В этой работе рассматривается
вычислимость именно в естественном кодировке.

Вводится понятия манера, который описиваеть поведение автомата в периоде когда обе счётчика
не равны \(0\). И вводится понятия функция маневра и функция маневра с переключателем, которых
можно вычислять за один маневр.

Вводится операции обобщенной суперпозиции и специальной рекурсии над функциями с переключателями.
И через этот операции будет введено класс функции называемые обобщенные функции маневра.

Дальше вводится понятия вычислительного графа, который служить для доказательства равенство
класса одноместных функции вычислимые через автоматы с двумя счётчиками и обобщенных функции
маневра.

\clearpage

\section{Основные определение и понятия}

Обозначим множества натуральных чисел через \(\N\), а множество целых чисел \(\Z\).
Положим \linebreak \(\N_0 = N \cup \{0\}\).  Определения
автомата совпадает с определением приведенное в \cite{litautomatatheory}.

\begin{definition}
  \label{def:automata}
  Автомат с \(n\) счётчиками называется семёрка \(\A = (A, Q, Q_f, B, \varphi, \bar{\psi}, q_0)\),
  где:
  \begin{itemize}
  \item \(A=\{0, 1\}^n\) --- входной алфавит
  \item \(Q\) --- множество состояний
  \item \(Q_f\) --- множество финальных состояний
  \item \(B=\{-1, 0, 1\}^n\) --- выходной алфавит
  \item \(\varphi: (Q \setminus Q_f) \times A \rightarrow Q\) --- функция переходов
  \item \(\bar{\psi}: (Q \setminus Q_f) \times A \rightarrow B\) --- функция выхода, которая состоит
    из \(n\) функции: \(\bar{\psi} = (\psi_1, \psi_2, \ldots, \psi_n)\).
  \end{itemize}
  При этом есть ограничения для \(\bar{\psi}\):
  \begin{equation}
    \label{eq:constraint}
    \forall i \in \{1, 2, \ldots, n\}\ (x_i = 0 \Rightarrow
    \psi_i(q, x_1, x_2, \ldots, x_i, \ldots, x_n) \geq 0)
  \end{equation}
\end{definition}

\begin{definition}
  \label{def:initialized_automata}
  Упорядоченного множество \((\A, z_1^0, z_2^0, \ldots, z_n^0)\) называется инициализированный
  автомат с \(n\) счётчиками, где
  \begin{itemize}
  \item \(\A\) --- автомат с \(n\) счётчиками
  \item \(z_i^0 \in \N_0\) --- начальным значениям \(i\)-счётчика, где \(i \in \{1, 2, \ldots, n\}\)
  \end{itemize}
\end{definition}

\begin{definition}
  \label{def:canonical}
  Пусть у нас есть инициализированный автомат с \(n\) счётчиками
  \((\A, z_1^0, z_2^0, \ldots, z_n^0)\).  Каноническими уравнениями называется система
  \ref{eq:canonical}
  \begin{equation}
    \label{eq:canonical}
    \begin{cases}
      q(0) = q_0 \\
      z_1(0) = z_1^0 \\
      z_2(0) = z_2^0 \\
      \ldots \\
      z_n(0) = z_n^0 \\
      q(t + 1) = \varphi(q(t), a(t)) \\
      z_1(t + 1) = z_1(t) + \psi_1(q(t), a(t)) \\
      z_2(t + 1) = z_2(t) + \psi_2(q(t), a(t)) \\
      \ldots \\
      z_n(t + 1) = z_n(t) + \psi_n(q(t), a(t))
    \end{cases}
  \end{equation}
  где
  \begin{align*}
    & t \in \N_0 \\
    & a(t) = (sign(z_1(t)), sign(z_2(t)), \ldots,
      sign(z_n(t))) \\
    & sign(x) =
      \begin{cases}
        -1, &x \in (-\infty; 0) \\
        0, &x = 0 \\
        1, &x \in (0; \infty)
      \end{cases} \\
  \end{align*}
\end{definition}

\begin{definition}
  \label{def:behaviour}
  Пусть у нас есть инициализированный автомат с \(n\) счётчиками
  \((\A, z_1^0, z_2^0, \ldots, z_n^0)\).
  \begin{itemize}
  \item Если существует момент времени \(t'\), такое что \(q(t') \in Q_f\), тогда поведением
    инициализированного автомата с \(n\) счётчиками называется конечная последовательность:
    \begin{align*}
      & (q(0), z_1(0), z_2(0), \ldots, z_n(0)) \\
      & (q(1), z_1(1), z_2(1), \ldots, z_n(1)) \\
      & \ldots, \\
      & (q(t'), z_1(t'), z_2(t'), \ldots, z_n(t'))
    \end{align*}
    В этом случае говорится инициализированный автомат с \(n\) счётчиками остановится.
  \item Если не существует момент времени \(t'\), такое что \(q(t') \in Q_f\), тогда поведением
    инициализированного автомата с \(n\) счётчиками называется бесконечная последовательность:
    \begin{align*}
      & (q(0), z_1(0), z_2(0), \ldots, z_n(0)) \\
      & (q(1), z_1(1), z_2(1), \ldots, z_n(1)) \\
      & \ldots, \\
      & (q(t), z_1(t), z_2(t), \ldots, z_n(t')) \\
      & \ldots
    \end{align*}
    В этом случае говорится инициализированный автомат с \(n\) счётчиками не остановится.
  \end{itemize}
\end{definition}

Автомат с \(n\) счётчиками можно рассмотреть как автомат соединенные с \(n\) внешними счётчиками,
каждый который может хранить неотрицательное число.  Автомат может видеть только то что, каждый
счётчик равно нулю или нет.  Каждый момент времени автомат может менять значения счётчика не более
чем на одну единицу, при этом значения счётчиков всегда должен остаться неотрицательным.
Ограничение \ref{eq:constraint} как раз таки обеспечивает неотрицательность счётчиков.

Рассмотрим автомат с двумя счётчиками.

\begin{definition}
  \label{def:manoeuvre}
  Пусть у нас есть инициализированный автомат с двумя счётчиками.  Конечным манёвром называется
  поведение автомата от момента времени \(t_1\) до \(t_2\):
  \begin{align*}
    & (q(t_1), z_1(t_1), z_2(t_1)), \\
    & (q(t_1 + 1), z_1(t_1 + 1), z_2(t_1 + 1)), \\
    & \ldots, \\
    & (q(t_2), z_1(t_2), z_2(t_2))
  \end{align*}
  если выполняется следующая условия:
  \begin{equation*}
    \begin{cases}
      z_1(t_1) = 0 \vee z_2(t_1) = 0 \\
      \forall t (t_1 \leq t < t_2 \Rightarrow q(t) \notin Q_f) \\
      \forall t (t_1 < t < t_2 \Rightarrow (z_1(t) \ne 0 \wedge z_2(t) \ne 0)) \\
      z_1(t_2) = 0 \vee z_2(t_2) = 0
    \end{cases}
  \end{equation*}
\end{definition}

\begin{definition}
  \label{def:notfull_manoeuvre}
  Пусть у нас есть инициализированный автомат с двумя счётчиками.  Непольным манёвром называется
  поведение автомата от момента времени \(t_1\) до \(t_2\):
  \begin{align*}
    & (q(t_1), z_1(t_1), z_2(t_1)), \\
    & (q(t_1 + 1), z_1(t_1 + 1), z_2(t_1 + 1)), \\
    & \ldots, \\
    & (q(t_2), z_1(t_2), z_2(t_2))
  \end{align*}
  если выполняется следующая условия:
  \begin{equation*}
    \begin{cases}
      z_1(t_1) = 0 \vee z_2(t_1) = 0 \\
      \forall t (t_1 < t \leq t_2 \Rightarrow (z_1(t) \ne 0 \wedge z_2(t) \ne 0)) \\
      q(t_2) \in Q_f
    \end{cases}
  \end{equation*}
\end{definition}

\begin{definition}
  \label{def:infinity_manoeuvre}
  Пусть у нас есть инициализированный автомат с двумя счётчиками.  Бесконечным манёвром называется
  поведение автомата от момента времени \(t_1\):
  \begin{align*}
    & (q(t_1), z_1(t_1), z_2(t_1)), \\
    & (q(t_1 + 1), z_1(t_1 + 1), z_2(t_1 + 1)), \\
    & \ldots
  \end{align*}
  если выполняется один из следующих условий:
  \begin{equation*}
    \begin{cases}
      z_1(t_1) = 0 \vee z_2(t_1) = 0\\
      \forall t (t_1 < t \Rightarrow (z_1(t) \ne 0 \wedge z_2(t) \ne 0 \wedge q(t) \notin Q_f))
    \end{cases}
  \end{equation*}
\end{definition}

Мы рассмотрим вычислимость частично определенных функции из \(m\) переменных, то есть функции,
которые имеет вид: \(f: M \rightarrow \N_0\), где \(M \subseteq \N_0^m\).  Будем
записать \(f(x_1, \ldots, x_m) = \lambda\), если \(f\) в точке \((x_1, \ldots, x_m)\) неопределено.

\begin{definition}
  \label{def:computability}
  Будем говорить что автомат \(\A\) с \(n\) счётчиками вычисляет функция \(m\)-переменных
  \linebreak
  \(f_{\A}: M \rightarrow \N_0\) (где \(M \subseteq \N_0^m\) и \(m \leq n\)), если:
  \begin{itemize}
  \item \(f_{\A}(x_1, x_2, \ldots, x_m) = y\) и инициализированный автомат
    \((\A, x_1, x_2, \ldots, x_m, 0, \ldots, 0)\) остановится, причем в момент остановки \(t'\)
    значения одного счётчика равно \(y\), а всех остальных равен \(0\)
  \item \(f_{\A}(x_1, x_2, \ldots, x_m) = \lambda\) и инициализированный автомат с \(n\) счётчиками
    \((\A, x_1, x_2, \ldots, x_m, 0, \ldots, 0)\) остановится, причем в момент остановки \(t'\)
    существует более чем один ненулевой счётчик.
  \item \(f_{\A}(x_1, x_2, \ldots, x_m) = \lambda\) и инициализированный автомат с \(n\) счётчиками
    \((\A, x_1, x_2, \ldots, x_m, 0, \ldots, 0)\) не остановится
  \end{itemize}
\end{definition}

Мы рассмотрим только частично определенных функции одной переменной.  Обозначим через \(J_n\)
множество всех частично определенных функции одной переменной, которые вычислимы через автоматы с
\(n\) счётчиками.  Очевидно что для любого \(n\) верно \(J_n \subseteq J_{n + 1}\).

Обозначим через \(\F\) все частично определенных функции одной переменной.

Множество значений функции \(f \in \F\) обозначим через \(Im(f)\).

\begin{definition}
  \label{def:switcher}
  Пусть \(g \in \F\).  \(g\) называется переключательной функцией, если
  \(\left|Im(g)\right| < \infty\).
\end{definition}

Обозначим через \(\G\) множество всех переключательных функции.

\begin{definition}
  \label{def:switcher_rang}
  Пусть \(g \in \G\).  \(\left|Im(g)\right|\) называется рангом функции \(g\).
\end{definition}

\begin{definition}
  \label{def:function_with_switcher}
  Пару \((f, g)\) называется функцию с переключателем, если \({f \in \F, g \in \G}\) и
  \linebreak
  \(\forall x [f(x) = \lambda \Leftrightarrow g(x) = \lambda]\).
\end{definition}

\begin{definition}
  \label{def:generalized_superposition}
  Пусть \(n \in \N\), \((f_0, g_0)\), \((f_1, g_1)\), \((f_2, g_2)\), \ldots,
  \((f_n, g_n)\) --- функции с переключателями и \linebreak
  \(E(g_0) = \{k_1, k_2, \ldots, k_n\}\).
  Тогда определим оператор обобщенной суперпозиции \(S_n\) следующим образом: если
  \((f, g) = S_n[(f_0, g_0), (f_1, g_1), (f_2, g_2), \ldots (f_n,
  g_n)]\), то \(f\) и \(g\) имеет вид
  \begin{align}
    \label{eq:generalized_superposition}
    & f(x) =
      \begin{cases}
        f_1(f_0(x)), & g_0(x) = k_1 \\
        f_2(f_0(x)), & g_0(x) = k_2 \\
        \ldots \\
        f_n(f_0(x)), & g_0(x) = k_n
      \end{cases} \\
    & g(x) =
      \begin{cases}
        g_1(f_0(x)), & g_0(x) = k_1 \\
        g_2(f_0(x)), & g_0(x) = k_2 \\
        \ldots \\
        g_n(f_0(x)), & g_0(x) = k_n
      \end{cases}
  \end{align}
  При этом для любого \(x \in \N_0\) если \(f_0(x) = \lambda\) (соответственно
  \(g_0(x) = \lambda\)), то \(f(x) = \lambda\) и \(g(x) = \lambda\)
\end{definition}

Прежде чем определять следующий оператор введем некоторые обозначения:
\begin{itemize}
\item \(f^k(x)\) --- это \(k\) раз применения функция \(f\) на \(x \in \N_0\).  Если для \(x\)
  существует \(l \in \overline{1, k}\), такая что \(f^l(x) = \lambda\), то \(f^k(x) = \lambda\).
\item Пусть \((f, g)\) --- функция с переключателем.  Тогда для любого \(a \in \N_0\)
  определим следующие множества:
  \begin{align*}
    & \Delta_0(a) = \{x \in \N_0 | g(x) = a\} \\
    & \Delta_{k + 1}(a) = \{x \in \Delta_{k} | g(f^{k + 1}(x)) = a\},\ \text{где}\ k \geq 0 \\
    & X_0(a) = \N_0 \setminus \Delta_0(a) \\
    & X_{k + 1}(a) = \Delta_{k}(a) \setminus \Delta_{k + 1}(a),\ \text{где}\ k \geq 0 \\
    & X_{\infty}(a) = \N_0 \setminus \bigcup_{k \geq 0} X_k(a)
  \end{align*}
\end{itemize}

\begin{definition}
  \label{def:special_recursion}
  Пусть \((f_0, g_0)\) --- функция с переключателем Тогда определим оператор специальной
  рекурсии \(R\) следующим образом: Если \((f, g) = R_a[(f_0, g_0)]\), то \(f\) и
  \(g\) имеет вид:
  \begin{align}
    \label{eq:generalized_superposition}
    & f(x) =
      \begin{cases}
        f^{k + 1}_0(x), & x \in X_k(a) \\
        \lambda, & x \in X_{\infty}(a)
      \end{cases} \\
    & g(x) =
      \begin{cases}
        g_0(x), & x \in X_0(a) \\
        g_0(f_0^k(x)), & x \in X_k(a), k \geq 1 \\
        \lambda, & x \in X_{\infty}(a)
      \end{cases}
  \end{align}
  При этом для любого \(x \in \N_0\) если \(f_0^l(x) = \lambda\) (где \(1 \leq l \leq k\)), то
  \(f(x) = \lambda\) и \(g(x) = \lambda\)
\end{definition}

\begin{definition}
  \label{def:periodic}
  Функцию \(f \in \F\) называется периодичным, если существует \(T \in \N\) и \(x_0 \in \N_0\),
  такое что для любого \(x > x_0\) и для любого \(k \in \N_0\) верно \(f(x) = f(x + kT)\).
\end{definition}

Аналогично определяется периодическая функция с целочисленными значениями.

Обозначим наимеший период функции \(g\) через \(T_{g}\).

Обозначим множество всех периодичных функции через \(\G_p\).  Очевидно что
\(\G_p \subset \G\).

\begin{definition}
  \label{def:pseudoperiodic}
  Функцию \(f \in \F\) называется псевдопериодичным, если существует \(x_0 \in \N_0\), такое что для
  любого \(x > x_0\) существует \(T \in \N\), такое что для любого \(k \in \N_0\) верно
  \(f(x) = f(x + kT)\).
\end{definition}

Обозначим множество всех псевдоперидочных функции через \(\F_p\).  Очевидно что
\(\G_p \subset \F_p\).

\begin{definition}
  \label{def:manoeuvre_function}
  Функцию \(f \in \F\) называется функцию маневра если она имеет один из следующих видов:
  \begin{align}
    \label{eq:manoeuvre_function}
    & f(x) =
      \begin{cases}
        C_0, & x = 0 \\
        C_1, & x = 1 \\
        \ldots \\
        C_k, & x = k \\
        \frac{a x + b(x)}{d}, & x > k
      \end{cases} \\
    \label{eq:manoeuvre_function_nd}
    & f(x) =
      \begin{cases}
        C_0, & x = 0 \\
        C_1, & x = 1 \\
        \ldots \\
        C_k, & x = k \\
        \lambda, & x > k
      \end{cases}
  \end{align}
  где \(C_0, C_1, \ldots C_k \in \N_0\), \(b(x)\) --- периодическая функция с
  целочисленными значениями, которая имеет предпериод \(k\) и период \(d\).
  Причем \(b(x)\) такая, что \(\frac{a x + b(x)}{d} \in \N_0\)
  для всех \(x \in \N_0\).  Число \(d\) называем шагом функции
  маневра и обозначим через \(d_{f}\).  А число \(k\) предманевр функции маневра и обозначим через
  \(k_f\).
\end{definition}

Обозначим множество всех функции маневра через \(\F_m\).

\begin{definition}
  \label{def:manoeuvre_function_switcher}
  Функцию с переключателем \((f, g)\) называем функция маневра с переключателем, если
  выполняется следующие условия: \(f \in \F_m\), \(g \in \G_p\) \(d_f = T_{g}\) и предманевр
  \(f\) совпадает предпериодом \(g\).
\end{definition}

Обозначим множество всех функции маневра с переключателем через \(\M_m\).

\begin{definition}
  \label{def:generalized_manoeuvre_function_with_switcher}
  Определим обобщенную функцию маневра с переключателем через индуктивное определение:
  \begin{enumerate}
  \item Любая функция маневра с переключателем это обобщенная функция маневра с переключателем.
  \item Для любого \(n \in \N\) и \(m \in \N_0\) если \((f_0, g_0)\), \((f_1, g_1)\),
    \((f_2, g_2)\), \ldots, \((f_n, g_n)\) является обобщенной функции маневра с
    переключателем, то функции
    \((f', g') = S_n[(f_0, g_0), (f_1, g_1), \ldots, (f_n, g_n)]\) и
    \((f'', g'') = R_a[(f_0, g_0)]\) тоже является обобщенной функции маневра с
    переключателем.
  \end{enumerate}
\end{definition}

Обозначим множество всех обобщенных функции маневра с переключателем через \(\M_2\).

\begin{definition}
  \label{def:generalized_manoeuvre_function}
  Функцию \(f\) называем обобщенная функция маневра, если существует \({g \in \G}\) такое что
  \linebreak
  \((f, g) \in \M_2\).
\end{definition}

Обозначим множество всех обобщенных функции маневра через \(\F_2\).

Определим еще одно понятия для доказательства теорем.

\begin{definition}
  \label{def:graph}
  Пусть нам дано ориентириванное дерево.
  Обозначим корень дерево через \(v_s\).
  И пусть выделено некоторое подмножество листьев этого дерева \(V_f\), которое будем называть
  множество финальных вершин.
  И проводим такую операцию несколько раз над вершинами графа:
  \begin{enumerate}
    \item Выделим некоторую вершину \(v \in V \setminus V_f\)
    \item Рассмотрим простую цепь \(v_s, v_1, v_2, \ldots, v\). И выбираем некоторую вершину \(v_i\)
      (возможно саму \(v\))
    \item Проводим ребро исходящее от \(v\) и заходяще в \(v_i\)
  \end{enumerate}
  В полученном графе пометим вершины меткой \((f, g)\), где \((f, g) \in \M \subseteq \F \times \G\).
  А ребра исходящие от \(v\) пометим значениями из множества \(Im(g)\), при этом мощность должен
  совпадать количеству исходящих ребер и у одной вершины не будет два ребра исходящие от неё,
  которые имеет одинаковые метки.
  И все ребра заходящие к одному вершину имеет одинаковые метки, а ребра заходящие разные вершины
  имеет разные метки.
  Полученный граф \(G\) называем вычислительный граф над множеством \(\M\).
\end{definition}

\begin{definition}
  \label{def:vertex_level}
  Пусть нам дано вычислительный граф \(G\) и пусть \(v\) его длина. Тогда длина кратчайший цепи
  от корня до этой вершины будем называть уровнем вершины \(v\).
\end{definition}

\begin{definition}
  \label{def:graph_level}
  Пусть нам дано вычислительный граф \(G\). Максимальный уровень среди всех вершин графа будем
  будем называть уровень графа.
\end{definition}

Вычислительный граф \(G\) принимает как вход некоторое \(x \in \N_0\) и дает другое число используя
следующий алгоритм:
\begin{enumerate}
\item В качестве активной вершины берём корень, а в качестве текущего значения берём текущее
  значения.
\item Если \(v_a \in V_f\), алгоритм закончится и в качестве ответа даем текущее занчения,
  если нет переходим на шаг 3.
\item Пусть активная вершина -- \(v\), текущая значения -- \(y\), а метка активной вершины -- \((f_v, g_v)\).
  Находим \(v'\), такое что метка \((v, v')\) равно \(g_v(y)\).
  И находим \(y' = f_v(y)\).
  Тогда в качестве текущей значении берём \(y'\), а активную вершину \(v'\), и переходим на шаг 2.
\end{enumerate}

Если алгоритм при некотором входном значении \(x \in \N_0\) не закончится
или в каком-то шаге функция \(f_(x)\) даёт неопределённость,
то считаем что вычислительный граф \(G\) даёт неопределённость как ответ.

Последовательность вершин \(v_1, v_2, \ldots, v_n\), которые были активны называем путь вычисления
\(x\).

\begin{definition}
  \label{def:graph_function}
  Вычислительный граф \(G\) над множеством \(\M\) вычисляет функцию \(f_G\), если \(G\) при
  входном значении \(x\) даёт ответ равную \(f(x)\) и даёт неопределённость, если функция \(f(x)\),
  не определено.
\end{definition}

Определим некоторые операции над вычислительными графами.

\begin{definition}
  \label{def:unite}
  Пусть дано вычислительный граф \(G\) над множеством \(\M\) и его вершина
  \(v \in V \setminus V_f\).  Пусть из вершины \(v\) исходит ребра, которые заходить к вершинам
  \(v_1, v_2, \ldots, v_n\).
  и имеет метки \(k_1, k_2, \ldots, k_n\) соответственно. При этом
  к вершинам \(v_1, v_2, \ldots, v_n\) не заходить другие ребра (в том числе они не имеет петли).
  Тогда определим операцию объединение над вершиной \(v\) следующим образом:
  \begin{enumerate}
  \item Поменяем метку вершины \(v\) на
    \(S_n[(f_v, g_v), (f_1, g_1), (f_2, g_2), \ldots, (f_n, g_n)]\).
    Здесь \((f_i, g_i)\) равно:
    \begin{itemize}
    \item метку вершины \(v_i\), если \(v_i \in V \setminus V_f\) и если уровень вершины
      \(v_i\) строго больше, чем уровен вершины \(v\).
    \item \((I, Const_{k_i})\), если \(v_i \in V \setminus V_f\) и если уровень вершины
      \(v_i\) не больше, чем уровен вершины \(v\).
    \item \((I, Const_{k_i})\), если \(v_i \in V_f\).
    \end{itemize}
  \item Удалим ребра исходящие от \(v\) и заходящие к вершинам \(v_{i_1}, v_{i_2}, \ldots, v_{i_k}\),
    которые является вершинами уровнем больше чем \(v\).
  \item Проводим ребро с меткой \(a\) исходящий от \(v\) к вершине, которому заходить ребро с той
    же меткой исходящий от вершин \(v_{i_1}, v_{i_2}, \ldots, v_{i_k}\).
    Если получится несколько ребер у вершины \(v\), которые заходить на одно вершину
    \(v'\) уровнем не больше чем уровень \(v\) (такое может случится, например если два вершины из
    \(v_{i_1}, v_{i_2}, \ldots, v_{i_k}\) имеет ребра заходящие к \(v'\)), то
    объединаем их (это корректно, поскольку все вершины заходящие к \(v'\) имеет одинакувую метку).
  \item Удалим вершины \(v_{i_1}, v_{i_2}, \ldots, v_{i_n}\)
  \end{enumerate}
\end{definition}

\begin{definition}
  \label{def:eliminate_loop}
  Пусть дано вычислительный граф \(G\) над множеством \(\M\) и его вершина \linebreak
  \(v \in V \setminus V_f\).  Пусть вершина \(v\) имеет петлю по метке \(a\). Тогда операцию
  устранения петли определим над вершиной \(v\) так:
  \begin{enumerate}
  \item Меняем метку вершины \(v\) на \(R_a[(f_v, g_v)]\)
  \item Удалим петлю с меткой \(a\)
  \end{enumerate}
\end{definition}

\clearpage

\section{Классические результаты}

%\begin{theorem}
  %\label{theor:one_counter}
  %\(J_1\) состоит из периодических функции и функции следующего вида:
  %\begin{equation*}
    %f(x) =
    %\begin{cases}
      %C_0, & x = 0 \\
      %C_1, & x = 1 \\
      %\ldots \\
      %C_k, & x = k \\
      %x + c, & x > k
    %\end{cases}
  %\end{equation*}
  %где \(C_0, C_1, \ldots, C_k \in \N_0 \cup \{\lambda\}\) и \(k, c \in \N_0\).
%\end{theorem}

\begin{theorem}
  \label{theor:three_counter}
  \(J_3\) совпадаеть с классом частично рекурсивных функции от одной переменной.
\end{theorem}

\begin{theorem}
  \label{theor:two_counter_special}
  Пусть у нас есть кодировка \(x \mapsto 2^x\).  В таком кодировке любая частично рекурсивная
  функция вычислима на автоматах с двумя счётчиками.
\end{theorem}

\clearpage

\section{Основной результать}

\begin{theorem}
  \label{computable_functions}
  \(\F_2 = J_2\).
\end{theorem}

\begin{hypothesis}
  Любая функция из \(J_2\) имеет вид:
  \begin{equation}
    \label{eq:pseudoperiodic}
    f(x) = \frac{a(x) \cdot x + b(x)}{d(x)}
  \end{equation}
  где \(a(x), b(x), d(x)\) является псевдопериодичными функциями.
\end{hypothesis}

\clearpage

\section{Леммы и доказательства}

\begin{lemma}
  \label{lemma:manoeuvre}
  Пусть дано автомат с 2 счётчиками \(\A\) с \(N\) состояниями.
  Нумеруем все состояния автомата: \linebreak
  \(q_0, q_1, q_2, \ldots, q_{N - 1}\).
  Пусть в момент времени \(t'\) для автомата верно один из двух условий:
  \begin{align}
    \label{eq:initial_status_1}
    & \begin{cases}
        q(t') = q_l \\
        z_1(t') = x \\
        z_2(t'') = 0
      \end{cases} \\
    \label{eq:initial_status_2}
    & \begin{cases}
        q(t') = q_l \\
        z_1(t') = 0 \\
        z_2(t'') = x
      \end{cases}
  \end{align}
  Тогда существует такое функция маневра с переключателем
  \((f, g) \in \M_m\), такое что для любого значения \(x\) верно:
  \begin{enumerate}
  \item Если автомат \((\A, x, 0)\) (автомат \((\A, 0, x)\)) совершает конечный маневр и этот маневр
    закончится момент времени \(t''\) и если при этом \(z_2(t'') = 0\), тогда \(f(x) = z_1(t'')\),
    \(g(x) = 2 l'\), где \(l'\) это номер состоянии \(q(t'')\).
  \item Если автомат \((\A, x, 0)\) (автомат \((\A, 0, x)\)) совершает конечный маневр и этот маневр
    закончится момент времени \(t''\) и если при этом \(z_1(t'') = 0\), тогда \(f(x) = z_2(t'')\),
    \(g(x) = 2 l' + 1\), где \(l'\) это номер состоянии \(q(t'')\).
  \item Если инициализированный автомат \((\A, x, 0)\) (автомат \((\A, 0, x)\)) совершает непольный
    маневр, тогда \linebreak \(f(x) = \lambda\), \(g(x) = \lambda\)
  \item Если инициализированный автомат \((\A, x, 0)\) (автомат \((\A, 0, x)\)) совершает \
    бесконечный маневр, тогда \(f(x) = \lambda\), \(g(x) = \lambda\)
  \end{enumerate}
\end{lemma}

\begin{proof}
  Мы будем доказывать только случая \ref{eq:initial_status_1}, так как случай
  \ref{eq:initial_status_2} доказывается аналогично.

  Заметим, что нам достаточно доказать утверждения начиная с некоторого \(k\),
  так как в выражениях \ref{eq:manoeuvre_function}
  и \ref{eq:manoeuvre_function_nd} значения констант \(C_0, C_1,
  \ldots, C_k\) можно задать как любое число,
  и в предпериоде \(g\) тоже может принимать любые значения.

  Рассмотрим два случая:
  \begin{itemize}
  \item Существует \(k\), такое что для любого \(x > k\) в конце маневра \(z_1(t'') > 0\).
    Тогда для любого \(x > k\) рассмотрим конечную последовательность входов автомата \((\A, x, 0)\):
    \begin{align*}
      & (a_1(t'), a_2(t')) \\
      & (a_1(t' + 1), a_2(t' + 1)) \\
      & \ldots \\
      & (a_1(t''), a_2(t''))
    \end{align*}
    где \({a_i(t) = sign(z_i(t))}\), для \({i \in \{1, 2\}, 0 \leq t \leq t^*}\).
    Для всех \({t' < t < t''}\), верно \linebreak
    \(z_1(t) > 0, z_2(t) > 0\), поскольку если это было не так,
    то существует момент времени \(t^*\), такое что \(t' < t^* < t''\) и
    \(z_1(t^*) = 0 \vee z_2(t^*) = 0\).
    Но это означает по определению маневра что маневр закончился бы момент времени \(t^* \ne t''\).
    Значить \(a_1(t) = 1\), для всех \(t' \leq t \leq t''\) (в моментах времени \(t'\) и \(t''\)
    \(a_1\) по условию равно \(1\)) и \(a_2(t') = 0, t' < t < t'' \Rightarrow a_2(t') = 1\).

    Докажем что существует \(t''\) такое что, для любого \(x_1, x_2 > k\) маневр автоматов
    \((\A, x_1, 0)\) и \((\A, x_2, 0)\) закончится в \(t''\), и последовательность состоянии совпадает.
    Обозначим \(t'' = \min(t''_1, t''_2)\), где \(t''_1, t''_2\) моменты завершение маневров для
    автоматов \((\A, x_1, 0)\) и \((\A, x_2, 0)\) соответственно.
    Через \(z_{ij}(t)\) обозначим значения \(j\)-счётчика \(i\)-автомата в момент времени \(t\).

    Докажем по индукции что \((\forall t)[t' \leq t \leq t'' \Rightarrow q^1(t) = q^2(t)]\),
    где \(q^1(t), q^2(t)\) -- состояния первого и второго автомата в момент времени \(t\).

    \begin{enumerate}
    \item База индукции. \(t = t_1\). Тогда \(q^1(t_1) = q^2(t_1)\) по условию.
    \item Шаг индукции. Пуст для момента времени \(t < t''\) условия выполняется: \(q^1(t) = q^2(t)\).
      Нужно доказать что \(q^1(t + 1) = q^2(t + 1)\).
      Поскольку мы уже доказали оба входные значения для всех \(t > t_1\) равно \(1\).
      Тогда \(q^1(t + 1) = \varphi(q^1(t), 1, 1) = \varphi(q^2(t), 1, 1) = q^2(t + 1)\).
    \end{enumerate}

    То есть до момента времени \(t''\) включительно состоянии первого и второго автомата совпадает.
    Но тогда их последовательность выходных символов тоже совпадает.
    От этого следует что \(z_{12}(t'') = z_{22}(t'')\), поскольку \(z_{12}(t') = z_{22}(t')\) и выходные
    последовательности совпадает. Пусть для определённости \(t'' = t''_1\).

    Тогда возможно два случая:
    \begin{enumerate}
    \item \(z_{12}(t''_1) = z_{22}(t''_1) = 0\). Тогда маневр второго автомата тоже закончится на момент
      \(t''_1\). Поскольку выходные последовательности совпадает, то значения счётчиков
      обоих автоматов меняется на одинаковое число, то есть \(z_{11}(t'') = z_{11}(t') + c = x_1 + c\) и
      \(z_{21}(t'') = z_{22}(t') + c = x_2 + c\). Тогда \(f(x) = x + c = \frac{1 \cdot x + c}{1}\) и
      \(g(x) = 2 * l'\), где \(q^1(t'') = q^2(t'') = q_l'\)
    \item \(z_{12}(t''_1) = z_{22}(t''_1) \ne 0 \wedge q^1(t'') = q^2(t'') \in Q_f\).
      Тогда, опять, маневр второго автомата тоже закончится на момент \(t''_1\).
      Но тогда \(f(x) = \lambda\) и \(g(x) = \lambda\)., поскольку обе счётчики ненулевые и
      соответственно это был непольный маневр.
    \end{enumerate}

  \item Для любого \(x_0\), существует такое \(x'\), такое что маневр автомата \((A, x', 0)\)
    закончится в момент времени \(t'\) и \(z_1(t'') = 0\).
    Пусть \(x\) такое число, что \(x > N + 1\) и в конце маневра \((A, x, 0)\) значения
    первого счётчика равно \(0\).

    Тогда \(z_1(t') = x > N + 1 \Rightarrow t'' - t' > N + 1\).
    И по определению конечного маневра верно следующее:
    \begin{equation*}
      t' < t < t'' \Rightarrow (z_1(t) > 0 \wedge z_2(t) > 0) \Rightarrow a_1(t) = 1 \wedge a_2(t) = 1
    \end{equation*}

    Тогда существует моменты времени \(t' < i < j < t''\), такое что \(q(i) = q(j)\), поскольку
    существует как минимум \(N + 1\) момент времени между \(0\) и \(t'\). Но количество состоянии
    автомата \(\A\) равно \(N\). Обозначим \(T = j - i\).
    Тогда:
    \begin{align*}
      & q(i) = q(i + T) \\
      & a_1(i) = a_1(i + T) \\
      & a_2(i) = a_2(i + T) \\
      & q(i + 1) = \varphi(q(i), a_1(i), a_2(i))
        = \varphi(q(i + T), a_1(i + T), a_2(i + T)) = q(i + T + 1) \\
      & j + 1 < t'' \Rightarrow a_1(i + 1)
        = sign(z_1(i + 1)) = sign(z_1(i + T + 1)) = a_1(i + T + 1) = 1\\
      & j + 1 < t'' \Rightarrow a_2(i + 1)
        = sign(z_2(i + 1)) = sign(z_2(i + T + 1)) = a_2(i + T + 1) = 1\\
      & \ldots \\
      & j + \delta < t'' \Rightarrow
        q(i + \delta) = \varphi(q(i + \delta - 1), a_1(i + \delta - 1), a_2(i + \delta - 1)) \\
      & = \varphi(q(i + T + \delta - 1), a_1(i + T + \delta - 1), a_2(i + T + \delta - 1))
        = q(i + T + \delta) \\
      & j + \delta < t'' \Rightarrow a_1(i + \delta)
        = sign(z_1(i + \delta)) = sign(z_1(i + T + \delta)) = a_1(i + T + \delta) = 1 \\
      & j + \delta < t'' \Rightarrow a_2(i + \delta)
        = sign(z_2(i + \delta)) = sign(z_2(i + T + \delta)) = a_2(i + T + \delta) = 1\\
     \end{align*}

     То есть начиная момента времени \(i\) и до момента времени \(t''\), последовательность
     состоянии и последовательность выходных символов совпадает. Это означает:
     \begin{align*}
       & i \geq t, t + T < t'' \Rightarrow z_1(t + T) - z_1(t) = const \in \Z \\
       & i \geq t, t + T < t'' \Rightarrow z_2(t + T) - z_2(t) = const \in \Z
     \end{align*}

     Есть три варианта:
     \begin{enumerate}
     \item \(z_2(t + T) - z_2(t) < 0\). Тогда автомат уменшает второй счётчик.
       Но тогда существует \(k\), такое что для всех \(x\) автомат \((\A, x, 0)\)
       закончит маневр с ненулевым первым счётчиком,
       поскольку в момент времени \(i\) значение второй счётчик зафиксирован, а значения первого
       счётчика возрастает с ростом \(x\).
       А это противоречит условию этого пункта

     \item \(z_2(t + T) - z_2(t) \geq 0, z_1(t + T) - z_1(t) \geq 0\). Это означает что за
       период обе счётчика не уменшались. А от этого следует маневр будет бесконечным, что тоже
       противоречит условию того пункта

     \item \(z_2(t + T) - z_2(t) \geq 0, z_1(t + T) - z_1(t) < 0\).
       Обозначим \(a = z_2(t + T) - z_2(t), d = z_1(t) - z_1(t + T)\).
       Тогда за период первый счётчик уменшиться на \(d\), а второй счётчик увеличится на \(a\).
       Обозначим \(b_1 = z_1(i) - z_1(t'), b_2 = z_2(i) - z_2(t')\). Тогда количество периодов
       который проходил автомат равно \(\lfloor \frac{x + b_1}{d} \rfloor\). И после столько периодов
       значения второго счётчика будет равно \(a \lfloor \frac{x + b_1}{q} \rfloor + b_2\).
       И в конце остаётся непольный период. И изменения за этот непольный период зависит от остатка
       \((x + b_1) \mod d\), когда непольный период начинается значения первого счётчика будет
       равно именно этому числу. По этому можно писать
       \(z_2(t'') = a \lfloor \frac{x + b_1}{d} \rfloor + b_2 + b'(x)\), где \(b'(x)\) --
       периодическая функция с периодом \(d\).
       Теперь заметим что \(\lfloor \frac{x + b_1}{d} \rfloor = \frac{x + b_1 + r(x)}{d}\), где
       \(r(x) = - ((x + b_1) \mod d)\).
       Делаем преобразования:
       \begin{align*}
         z_2(t'') & = a \frac{x + b_1 + r(x)}{d} + b_2 + b'(x)
                  = \frac{a x + a b_1 + a r(x) + d b_2 + d b'(x)}{d}
                  = \frac{a x + b(x)}{d} \\
       \end{align*}
       где \(b(x)\) -- периодическая функция с периодом \(d\) и с целочисленными значениями.

       Теперь нужно доказать что начиная с некоторого \(x\) поведение автомата всегда будет такой.
       Но это верно потому периодичность поведение не зависить от \(x\), если \(x\) достаточно
       большой.

       Осталось доказать что состояния при моменте времени \(t''\) будет периодический зависет от
       \(x\). Это верно в силу того если мы вместо \(x\) берём \(x + d\), то непольный период в
       конце начинается с одинаковых значений первого счётчика, и как следствия маневры закончится
       в одинаковых состояниях.

       Таким образом \(f(x) = \frac{a x + b(x)}{d}\) и \(g(x)\) тоже является периодичной функцией
       с периодом \(d\).
     \end{enumerate}

  \item Для любого \(x_0\), существует такое \(x'\), такое что маневр автомата \((\A, x', 0)\)
    не закончится. Тогда повторяя рассуждения предедущего пункта, можно доказать что поведения
    опять будет периодичным и за период счётчики не уменьшинтся. Соответственно для любого
    \(x \geq x'\) маневр автомата \((\A, x', 0)\) будет бесконечным.
    Соответственно \(f(x) = \lambda, g(x) = \lambda\).
  \end{itemize}
\end{proof}

По лемме \ref{lemma:manoeuvre} каждому состоянию автомата \(\A\) можно сопоставить
две функции маневра с переключателем, зависимости от значения какого счётчик равно 0.

\begin{lemma}
  \label{lemma:automata_to_graph}
  Пусть дано автомат \(\A\) и пусть это автомат вычисляет функция
  \(f_{\A} : \N_0 \rightarrow \N_0\).  Тогда существует вычислительный граф над множеством
  \(\M_m\), который вычисляет ту же функцию \(f_{\A}\).
\end{lemma}

\begin{proof}
  Пусть автомат \(\A\) имеет \(N\) состоянии.
  Для каждого не финального состояния \(q_l\), построим две функции маневра с переключателем \((f_{2l}, g_{2l}),
  (f_{2 l + 1}, g_{2 l + 1})\) по лемме \ref{lemma:manoeuvre}. Построим граф \(G\) из пустого графа по уровням вершин
  (обозначим через \(i\) текущий уровень):
  \begin{enumerate}
  \item \(i = 0\) (по определению существует только одна вершина, которая имеет уровен \(0\)).
    Если верно \(q_0 \in Q_f\), то сразу остановимся.
    Добавим вершину обозначаемую через \(v_0\), и пометим эту вершину функцией \((f_0, g_0)\).
    Добавим \(|Im(g_0) \ \{0\}|\), вершин и проводим ребра от \(v_0\) с метками из \(Im(g_0) \ \{0\}\).
    Если \(0 \in Im(g_0)\), тогда проводим петлю с меткой \(0\).
  \item \(i > 0\). Пусть построено \(i\) уровень.
    Для каждой нефинальной вершины \(i + 1\)-уровня сделаем следующую действию.
    Пусть \(v\) --- вершина с уровнем \(i + 1\). Тогда рассмотрим ребро заходящий к \(v\) имеет
    метку \(l\), тогда переобозначим вершину через \(v_l\) и пометим эту вершину через \((f_l, g_l)\).
    Если для этой состоянии не определно \((f_l, g_l)\), что означаеть соответствующая вершина
    финальная, то пометим вершину \(v_l\) как финальную.
    Пусть \(v_0, v_{j_1}, v_{j_2}, \ldots, v_l\) является кратчайшей простой цепью от \(v_0\) до \(v_l\)
    и пусть \(k \in Im(g)\).
    \begin{itemize}
    \item Если в графе существует вершина \(v_k\) и она находится в выше указанном цепи,
      то проводим ребро с меткой \(k\) к вершину \(v_k\).
    \item Если \(v_k\) не находится в выше указанном цепи,
      то добавим вершину и проводим ребро с меткой \(k\) к этому вершину.
    \end{itemize}
  \item Если в течении шага 2 добавили только финальные вершины и ребра уже существующим вершинам,
    то закончим алгоритм, если нет то в качестве \(i\) берём \(i + 1\) и повторяем шаг 2
  \end{enumerate}

  Докажем что алгоритм конечный. Это следует из-за того что каждый кратчайший простой цепь не длиннее
  чем \(2  N\) (потому что у нас \(N\) состоянии у автомата, от этого следует число разных вершин
  максимум \(2 N\)). От этого следует конечность алгоритма.

  Теперь докажем что они вычисляет одинаковые функции. Пусть \(x\) дано как значения первого счётчика
  и как входное значения графа \(G\).
  Докажем что для любого \(n\),
  значения счётчика в начале \(n\)-маневра совпадает с текущем значениям в \(n\)-шаге графа, и
  функция с переключателем который соответствует текущему состояния автомата и значении нулевых
  счётчиков совпадает с меткой активной вершины.
  Докажем через индукцию:
  \begin{enumerate}
  \item База индукции. \(n = 0\). Входное значения равно начальному значения счётчика (это по условии).
    А функция соответствующий к \(q_0, z_2(0) = 0\), по построению графа как раз таки совпадает с
    меткой корня.
  \item Шаг индукции. Пусть утверждения доказано для \(n = k\), тогда докажем это утверждения для
    \(n = k + 1\). Если утверждения верно для \(n = k\), то это означает что означает значения
    одного счётчика совпадает с текущем значениям для шага \(k\). Тогда значения в шаге \(n = k + 1\),
    тоже совпадает, поскольку мы в шаге \(k\) вычисляем одинаковые функции. Текущие функции совпадает
    в силу построения
  \end{enumerate}
\end{proof}

\begin{lemma}
  \label{lemma:manoeuvre_function}
  Пусть дано функция маневра с переключателем \((f, g)\).
  Тогда существует автомат с 2 счётчиками \(\A\) c множеством состоянии, которое cодержит:
  \(\{q_{i_1}, q_{i_2}, \ldots, q_{i_l}\}\), где \(\{i_1, i_2, \ldots, i_l\} = Im(g)\) и для
  которого верно.
  \begin{itemize}
  \item Если \(f(x) = \lambda, g(x) = \lambda\), то инициализированный автомат \((\A, x, 0)\)
    либо совершает бесконечный маневр, либо совершает непольный маневр.
  \item Если \(f(x) = y, g(x) = i_j\) то автомат \((\A, x, 0)\) совершает 3 конечных маневра и
    в конце будет \linebreak
    \(q(t) = q_{i_j}, z_1(t) = y, z_2(t) = 0\).
  \end{itemize}
\end{lemma}

То есть в этой лемме будет построен автомат который реализует функцию через 3 конечных маневра,
но в конце 2-счётчик всегда будет равно 0.

\begin{proof}
  Для каждого значения \(g(x)\) добавим соответствуюшую состоянию.
  Пусть предманевр \(f\) и предпериод \(g\) равно \(k\), и \(С_0, C_1, \ldots C_k\) и \(i_0,
  i_1, \ldots, i_k\) первые значения функции \(f\), \(g\) соответственно.
  Предманевр моделируется так:
  \begin{enumerate}
  \item Первый маневр.
    \begin{itemize}
    \item Случай когда \(x = 0\). Автомат первый шаг автомата будет увеличить оба счётчика.
      Потом не меняя первый счётчик, сделаем так, чтобы значения первого счётчика было равно \(C_0\).
      Потом уменьшаем значения первого счётчика.
      Автомат закончить маневр на состоянии \(q'_{g(x)}\)

    \item Случай когда \(0 < x \leq k\). Тогда сначала автомат сделает значения второго счётчика
      \(C_1\). И потом уменшает первый счётчик. Если \(x = 1\), то тогда маневр закончится и значения
      второго счётчика будет \(C_1\). Если \(x > 1\), то теперь сделает значения 2-счётчика \(C_2\) и
      уменьшает счётчик 1. И так далее до \(k\).
      Если после \(k\) уменьшение первого счётчика значение не будет \(0\) (это означает \(x > k\)),
      то возвращается к значениям счётчика \(z_1(t) = x, z_2(t) = 1\) (\(z_2(t) = 1\) чтобы не закончит
      маневр). Здесь тоже когда уменьшаем значения 2-счётчика, нужно переходить на состояния
      \(q'_{g(x)}\).

    \item Случай когда \(x > k\) и когда автомат уже возвращаелся к \(z_1(t) = x, z_2(t) = 1\).
      Если значения для \(x > k\) неопределено то просто автомат остановится и удовлетворим условию леммы.

      Теперь случай когда это не так.
      Тогда \(f(x) = \frac{a x + b(x)}{d}\)
      Автомат \(\A\) начинает совершать периодическое спуск. Настроим автомат таким образом:
      За один период автомат уменьшает значения
      первого счётчика на \(q\), а значения второго счётчика увеличивает на \(p\).
      При этом как он будет проходить этот период зависить от функции \(b(x)\).
      Зависимости от значения этой функции, автомат каждый перед уменьшением 1-счётчика, изменить
      второй счётчик нужным образом. Автомат закончить маневр на состоянии \(q'_{g(x)}\)
    \end{itemize}

  \item Второй маневр.
    В ходе второго манерва каждом шаге уменьшим 2-счётчик, и увеличиваем 1-счётчик в каждом шаге
    и остаемся в состоянии \(q'_{g(x)}\). Тогда в конце этого маневра будет \(q(t) = q'_{g(x)},
    z_1(t) = f(x), z_2(t) = 0\)

  \item Третий маневр.
    Не изменяя значения счётчиков переводим состояния от \(q'_{g(x)}\) на \(q_{g(x)}\).
  \end{enumerate}

  Тогда в конце получим \(q(t) = q_{g(x)}, z_1(t) = f(x), z_2(t) = 0\).
\end{proof}

\begin{lemma}
  \label{lemma:graph_to_automata}
  Пусть дано вычислительный граф \(G\) над множеством \(\M_m\) и пусть это граф вычисляет функция
  \(f_G : \N_0 \rightarrow \N_0\).  Тогда существует автомат с двумя счётчиками, который
  вычисляет ту же функцию \(f_{G}\).
\end{lemma}

\begin{proof}
  Пусть вычислительный граф состоит из не финальных вершин \(\{v_0, v_1, \ldots, v_n\}\) и
  множество финальных вершин \(\{v'_0, v'_1, \ldots, v'_m\}\). Тогда для каждой не финальный вершины
  будем составить программу автомата \(\A_i\) по лемме \ref{lemma:manoeuvre_function}, где \(0 \leq i \leq n\).
  И просто объединаем все программы и начальной состоянии автомата будет состояния, которая
  соответствует к корню.
  Полученное автомат будет вычислять ту же функцию \(f_G\). Это выходить из построения автомата \(\A\)
  и доказывается по индукции как в лемме \ref{lemma:automata_to_graph}
\end{proof}

\begin{lemma}
  \label{lemma:unite_closure}
  Пусть дано вычислительный граф \(G\) над множеством \(\M \subseteq \F \times \G\),
  который вычисляет функцию \(f_G: \N_0 \rightarrow \N_0\) и пусть \(v \in V \setminus V_f\).  Тогда
  граф \(G^*\), полученное применением операции объединение над \(v\) тоже является
  вычислительным графом и тоже вычисляет функцию \(f_G\).
\end{lemma}

\begin{proof}
  Вершины в графе \(G\), удаленные в результате операции обозначим через \(v_1, v_2, \ldots, v_n\).
  Докажем что граф \(G^*\) остается связным, потому что если в графе \(G\) от вершины \(v_i\) исходить
  ребро с меткой \(а\) в вершину \(v'\), то в графе \(G^*\), ребро такой же меткой и заходящее в
  \(v'\) исходить от вершины \(v\). То есть для всех вершин, для которых существовал путь от корня
  к этим вершинам проходящий через вершины \(v\) и \(v_i\) в графе \(G\),
  тоже существует путь от корня до этих вершин в графе \(G^*\). От этого следует что \(G^*\) остается
  связным.

  Еще в графе \(G^*\) не возникает ситуации когда одну вершину \(v'\) заходить два ребра
  исходяшие от вершин более низкого уровня, поскольку в графе \(G\) это было не так, а в ходе
  операции мы только можем заменят одно ребро заходящий к вершину \(v'\) с одним ребром заходящую к
  вершину \(v'\), но возможно исходящую от другой вершины. От этого следует что если не рассмотреть
  ребро исходящий от вершины уровня \(i\) и заходящий к вершину \(j \leq i\), то получиться
  ориентированное дерево. То есть граф \(G^*\) является вычислительным графом.

  Осталось доказать что граф \(G^*\) вычисляет ту же функцию, что и \(G\).
  Если путь вычисления числа \(x\) не проходить через \(v\) в графах \(G\) и \(G'\), то они
  даёт одинаковый ответ. Если путь вычисления \(x\) в графе \(G\) проходить через \(v\), но
  следующая вершина в пути либо финальная вершина, либо вершина уровня не больше уровня \(v\).
  Но тогда по определению операции объединение в этом случае тоже ничего не меняется.
  И наконец, пусть путь вычисления \(x\) в графе \(G\) проходить через \(v\) и \(v_i\).
  И пусть \((f, g)\) и \((f_i, g_i)\) метки вершины \(v\) и \(v_i\), а метка ребра исходящий
  от \(v\) и заходящий в вершину \(v_i\) является \(k_i\).
  Тогда эти два вершины вычисляет функцию \(f_i(f(y))\), где \(y\) текущая значения на вершине
  \(v\) и определяет какая вершина будет следующая через \(g_i(f(y))\). Но по определению
  операции объединение если в вершине \(g(y)\) равно \(k_i\), то вычисляется функция \(f_i(f(y))\)
  и следующая вершина определяется через \(g_i(f(y))\). А это означает граф \(G\) и \(G^*\)
  даёт одинаковый ответ в этом слуае тоже.
\end{proof}

\begin{lemma}
  \label{lemma:eliminate_loop_closure}
  Пусть дано вычислительный граф \(G\) над множеством \(\M \subseteq \F \times \G\),
  который вычисляет функцию \(f_G: \N_0 \rightarrow \N_0\) и пусть \(v \in V \setminus V_f\).  Тогда
  граф \(G^*\), полученное применением операции устранения петли над \(v\) тоже является
  вычислительным графом и тоже вычисляет функцию \(f_G\).
\end{lemma}

\begin{proof}
  Мы применяя эту операцию просто удалили одну петлю. Соответственно \(G^*\) --- вычислительный граф
  над множеством \(\M'\) (возможно отличный от \(\M\)). Докажем, что вычислимая функция
  \(f_G\) остался таким же. Рассмотрим любую \(x\), путь вычисления которого содержить \(v\) и
  проходить через ребро с меткой \(a\) (которая была меткой петли). Других случаях пути вычисления
  \(x\) совпадает для \(G\) и \(G^*\).

  Тогда пусть в \(G\), путь вычисления \(x\) проходить \(k\) раз подряд. Это означает для любого
  \(i < k\), \(g(f^i(x)) = a\). Соответственно в графе \(G\), после прохождения \(v\) вычисляется
  функция \(f^{k + 1}(x)\) и \(g(f^k(x))\).

  Теперь рассмотрим путь вычисления в графе \(G^*\). Поскольку \(x\) такое число что
  \(g(f^k(x)) \ne a\), но для любого \(i < k\), \(g(f^i(x)) = a\)
  то по определению оператора \(R_a\), вычисляется как раз таки функции \(f^{k + 1}(x)\) и
  \(g(f^k(x))\).
\end{proof}

\begin{lemma}
  \label{lemma:graph_to_function}
  Пусть дано вычислительный граф \(G\) над множеством \(\M_m\). Тогда функция \(f_G\)
  которая вычисляет граф является обобщенная функция маневра, то есть \(f_G \in \F_2\)
\end{lemma}

\begin{proof}
  Производим следующие действия над графом \(G\):
  \begin{enumerate}
  \item \(i\) уровень вершин, Которые мы рассмотрим. В начале \(i\) равно уровень графа.
  \item Рассмотрим все вершины уровня \(i\). Если все вершины уровня \(i\) является финальными
    вершинами, то в качестве новой значении \(i\) берём \(i - 1\) и переходим на 2 шаг.
  \item Если какой-то вершина \(v\) уровня \(i\) имеет петю, то применяем к
    этой вершине операцию устранения петли.
  \item Дальше рассмотрим вершину \(v\) уровня \(i - 1\) и для каждой из них применяем операцию объединение.
    Вершине \(v\) можно применять операцию объединение, поскольку все вершины \(i\) имеет полустепень
    захода \(1\). Это следует из построение вычислительного графа и от того что вершины степены \(i\)
    не имеет петли, поскольку мы эти петли устранили предедущем шаге.
    Если \(i - 1 = 0\),  то закончим алгоритм. Если нет то уменьшаем значения \(i\) и повторяем 2 шаг.
  \end{enumerate}

  Алгоритм конечный, поскольку каждом цикле мы убираем все не финальные вершины одного уровня,
  и как следствия количество не финальных вершин всегда уменьшается.

  В конце остается только корень \(v_0\) и если метка этой вершины \((f, g)\), то функция \(f_G\),
  которая вычислима в вычисительной графе \(G\) равно \(f\). Это следует от леммы
  \ref{lemma:unite_closure} и \ref{lemma:eliminate_loop_closure}.
\end{proof}

\begin{lemma}
  \label{lemma:function_to_graph}
  Пусть дано обобщенная функция маневра с переключателем \((f, g)\) и
  пусть \(Im(g) = {k_1, k_2, \ldots, k_n}\).
  Тогда можно построить вычислительный граф \(G\), финальных вершин которых является
  \(v_{k_1}, v_{k_2}, \ldots, v_{k_n}\) и для которого верно:
  \begin{itemize}
  \item Вычислительный граф вычисляет функцию \(f\)
  \item Если \(g(x) = k_i\), то граф вычисления закончить в финальной вершине \(v_{k_i}\)
  \end{itemize}
\end{lemma}

\begin{proof}
  Докажем по индукции по построению функции:
  \begin{enumerate}
  \item Базис индукции. Пусть функция \((f, g) \in \M_m\). Тогда можно постороить вычислительный граф
    с единственным нефинальной вершиной c пометкой \((f, g)\) и соответствующими \(Im(g)\)
    финальными вершинами.
  \item Шаг индукции. Пусть существует графы \(G_0, G_1, \ldots G_n\) который вычисляет
    функцию \linebreak
    \((f_0, g_0), (f_1, g_1), \ldots, (f_n, g_n) \in \M_2\).
    \begin{enumerate}
    \item Докажем что существует граф вычисляющий \(S_n[(f_0, g_0), (f_1, g_1), \ldots (f_n, g_n)]\).
      Построим это граф таким образом: удалим финальную вершину \(v_{i_k}\) который
      соответствует значению \(k_i\) из \(Im(g_0)\), вместо этой вершины подставим граф \(G_i\)
      (то есть граф который соответствует функцию \((f_i, g_i)\), которая вычисляется при \(g_0(x) = k_i\)).
      Это процедуру повторим для всех вершин и очевидно что полученный граф \(G'\) удовлетворяет
      условию \(S_n[(f_0, g_0), (f_1, g_1), \ldots (f_n, g_n)]\)
    \item Докажем что существует граф вычисляющий \(R_a[f_0, g_0]\).
      Если \(a \notin Im(g_0)\), то в качестве ответа можем брать исходный граф \(G_0\).
      Если \(a \in Im(g_0)\), то берём граф \(G_0\), удалим от фтинальную вершину соответствующий
      к \(a\) и проводим заходящую к этой вершины ребро проводим в корень. По определению оператора
      \(R_a\) и по построению нового графа полученный граф удовлетворяет условия для \(R_a[f_0, g_0]\)
    \end{enumerate}
  \end{enumerate}
\end{proof}

\begin{theorem}
  \label{computable_functions}
  \(\F_2 = J_2\).
\end{theorem}

\begin{proof}
  По лемме \ref{lemma:automata_to_graph} и \ref{lemma:graph_to_function} можно утверждать
  что \(\F_2 \subseteq J_2\).
  По лемме \ref{lemma:function_to_graph} и \ref{lemma:graph_to_automata} можно утверждать
  что \(J_2 \subseteq \F_2\).
  От этого выходить что \(\F_2 = J_2\)
\end{proof}

\clearpage

\section{Заключения}

В результате данной работы было получено способ задания функции вычислимые через автомат с двумя
счётчками через специальных класс парных функции и специальных операции над ними. Возможно можно
построить более общий вид этих операции, который будет применими не только автоматам с двумя
счётчиками но и другим автоматным устройствам.

Если приведенная гипотеза о виде функции вычислимые через автоматы с двумя счётчиками будет
доказано, это позволяеть утверждать функции растущие быстрее чем линейные функции (например
\(x^2, 2^x\)) и функции растущие медленнее чем линейные функции \(\lfloor \log_2 x \rfloor,
\lfloor \sqrt(x) \rfloor\) не вычислимые через автоматы с двумя счётчиками.

Автор выражает благодарность научному руководителю Н.Ю. Волкову за постановку задачи, за помощь и
за ценные советы в ходе написании курсовой.

\clearpage

\begin{thebibliography}{}
\bibitem{litautomatacounters} Кузьмин Е.В., Соколов В.А.  \textit{Автоматные счетчиковые
    машины}. Ярославль, 2012.
\bibitem{litautomatatheory} Кудрявцев В.Б., Алешин С.В., Подколзин А.С.  \textit{Введение в теорию
    автоматов}. Наука, 1985.
\bibitem{litautomatalanguages} Д. Хопкрофт, Р. Мотвани, Д. Ульман \textit{Введение в теорию
    автоматов, языков и вычислений}. 2-е изд. : Пер. с англ. --- Москва, Издательский дом
  ``Вильямс'', 2002.
\end{thebibliography}

\end{document}