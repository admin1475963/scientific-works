\documentclass[14pt, a4paper, oneside]{article}

\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{fontspec}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{amsthm}
\usepackage{indentfirst}
\usepackage[left=3cm,right=1cm,
    top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{sectsty}

\makeatletter
\newenvironment{sqcases}{%
  \matrix@check\sqcases\env@sqcases
}{%
  \endarray\right.%
}
\def\env@sqcases{%
  \let\@ifnextchar\new@ifnextchar
  \left\lbrack
  \def\arraystretch{1.2}%
  \array{@{}l@{\quad}l@{}}%
}
\makeatother

\setmainfont{Heuristica}
\sectionfont{\centering}

\newtheorem{definition}{Определение}
\newtheorem{theorem}{Теорема}[section]
\newtheorem{consequence}{Следствие}[section]
\newtheorem{note}{Замечание}
\newtheorem{lemma}{Лемма}
\newtheorem{hypothesis}{Гипотеза}
\renewcommand{\thetheorem}{\arabic{theorem}}
\renewcommand{\theconsequence}{\arabic{consequence}}

\DeclareMathOperator{\sign}{sign}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\F}{\mathcal{F}}
\newcommand{\G}{\mathcal{G}}
\newcommand{\M}{\mathcal{M}}

\begin{document}

\thispagestyle{empty}

\begin{center}
  \Large
  МОСКОВСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ \\
  \bigskip
  имени М.В.Ломоносова \\
  \bigskip
  Филиал в г.Ташкенте \\
  \bigskip
  Факультет Прикладной Математики и Информатики \\
  \bigskip
  \hrule
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \textbf{Курсовая работа} \\
  \bigskip
  \textbf{Вычисление функций автоматами со счётчиками} \\
  \bigskip
  \bigskip
  \Large
  Подготовил: \\
  Студент третьего курса факультета ПМиИ \\
  Илхомов Мухаммад Муроджон угли \\
  \bigskip
  \bigskip
  Научный руководитель: \\
  Волков Николай Юрьевич \\
  \bigskip
  \hrule
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \textbf{2022}
\end{center}

\clearpage

\linespread{1.25}

\normalsize
\tableofcontents

\clearpage

\section{Введение}

В данной работе изучаются одноместные частичные функции, вычислимые через автоматы с двумя
счётчиками. Уже давно известно, что при специальной кодировке
автомат с двумя счётчиками может моделировать автомат с тремя счётчиками и, как следствие, может
вычислять любые одноместные функции, вычислимые по Тьюрингу. В этой работе рассматривается
вычислимость в естественной кодировке.

Вводится понятие манёвра, как простой части поведение автомата с 2 счётчиками.
И вводятся понятия функции манёвра и функции манёвра с переключателем, которые
можно вычислять за один манёвр.

Вводятся операции обобщенной суперпозиции и специальной рекурсии над функциями с переключателями.
И через эти операции будет введен класс функций, называемых обобщенными функциями манёвра.

Дальше вводится понятие вычислительного графа, который служит для доказательства равенства
класса одноместных функций, вычислимых через автоматы с двумя счётчиками и класса обобщенных функций
манёвра.

\clearpage

\section{Основные определения и понятия}

Обозначим множество натуральных чисел через \(\N\), а множество целых чисел через \(\Z\).
Положим  \(\N_0 = N \cup \{0\}\).  Определение
автомата совпадает с определением, приведенным в \cite{litautomatatheory}.

\begin{definition}
  \label{def:automata}
  Автоматом с \(n\) счётчиками называется семёрка \(\A = (A, Q, Q_f, B, \varphi, \bar{\psi}, q_0)\),
  где:
  \begin{itemize}
  \item \(A=\{0, 1\}^n\) --- входной алфавит
  \item \(Q\) --- множество состояний
  \item \(Q_f \subseteq Q\) --- множество финальных состояний
  \item \(B=\{-1, 0, 1\}^n\) --- выходной алфавит
  \item \(\varphi: (Q \setminus Q_f) \times A \rightarrow Q\) --- функция переходов
  \item \(\bar{\psi}: (Q \setminus Q_f) \times A \rightarrow B\) --- функция выхода, которая состоит
    из \(n\) функций: \(\bar{\psi} = (\psi_1, \psi_2, \ldots, \psi_n)\).
  \end{itemize}
  При этом есть ограничения для \(\bar{\psi}\):
  \begin{equation}
    \label{eq:constraint}
    \forall i \in \{1, 2, \ldots, n\}\ (x_i = 0 \Rightarrow
    \psi_i(q, x_1, x_2, \ldots, x_i, \ldots, x_n) \geq 0)
  \end{equation}
\end{definition}

\begin{definition}
  \label{def:initialized_automata}
  Упорядоченное множество \((\A, z_1^0, z_2^0, \ldots, z_n^0)\) называется инициализированным
  автоматом с \(n\) счётчиками, где
  \begin{itemize}
  \item \(\A\) --- автомат с \(n\) счётчиками
  \item \(z_1^0, z_2^0, \ldots, z_n^0\) --- неотрицательные целые числа
  \end{itemize}
  Здесь \(z_i^0\) называется начальным значением \(i\)-счётчика.
\end{definition}

\begin{definition}
  \label{def:canonical}
  Пусть у нас есть инициализированный автомат с \(n\) счётчиками
  \((\A, z_1^0, z_2^0, \ldots, z_n^0)\).
  Каноническими уравнениями \((\A, z_1^0, z_2^0, \ldots, z_n^0)\) называются система:
  \ref{eq:canonical}
  \begin{equation}
    \label{eq:canonical}
    \begin{cases}
      q(0) = q_0 \\
      z_1(0) = z_1^0 \\
      z_2(0) = z_2^0 \\
      \ldots \\
      z_n(0) = z_n^0 \\
      q(t + 1) = \varphi(q(t), a(t)) \\
      z_1(t + 1) = z_1(t) + \psi_1(q(t), a(t)) \\
      z_2(t + 1) = z_2(t) + \psi_2(q(t), a(t)) \\
      \ldots \\
      z_n(t + 1) = z_n(t) + \psi_n(q(t), a(t))
    \end{cases}
  \end{equation}
  где
  \begin{align*}
    & t \in \N_0 \\
    & a(t) = (\sign(z_1(t)), \sign(z_2(t)), \ldots,
      \sign(z_n(t))) \\
    & \sign(x) =
      \begin{cases}
        -1, &x \in (-\infty; 0) \\
        0, &x = 0 \\
        1, &x \in (0; \infty)
      \end{cases} \\
  \end{align*}
\end{definition}

\begin{definition}
  \label{def:configuration}
  Упорядоченное множество \((q(t), z_1(t), \ldots, z_n(t))\) называется конфигурацией в момент
  времени \(t\).
\end{definition}

\begin{definition}
  \label{def:behaviour}
  Пусть у нас есть инициализированный автомат с \(n\) счётчиками
  \((\A, z_1^0, z_2^0, \ldots, z_n^0)\).
  \begin{itemize}
  \item Если существует момент времени \(t'\), такой что \(q(t') \in Q_f\), тогда поведением
    инициализированного автомата с \(n\) счётчиками называется конечная последовательность:
    \begin{align*}
      & (q(0), z_1(0), z_2(0), \ldots, z_n(0)) \\
      & (q(1), z_1(1), z_2(1), \ldots, z_n(1)) \\
      & \ldots, \\
      & (q(t'), z_1(t'), z_2(t'), \ldots, z_n(t'))
    \end{align*}
    В этом случае говорится, что инициализированный автомат с \(n\) счётчиками остановится.
  \item Если не существует момент времени \(t'\), такой что \(q(t') \in Q_f\), тогда поведением
    инициализированного автомата с \(n\) счётчиками называется бесконечная последовательность:
    \begin{align*}
      & (q(0), z_1(0), z_2(0), \ldots, z_n(0)) \\
      & (q(1), z_1(1), z_2(1), \ldots, z_n(1)) \\
      & \ldots, \\
      & (q(t), z_1(t), z_2(t), \ldots, z_n(t')) \\
      & \ldots
    \end{align*}
    В этом случае говорится, что инициализированный автомат с \(n\) счётчиками не остановится.
  \end{itemize}
\end{definition}

Автомат с \(n\) счётчиками можно рассмотреть как автомат, соединенный с \(n\) внешними памятями,
где каждый может хранить неотрицательное число.  Автомат может видеть только то, что каждый
счётчик равно нулю или нет.  Каждый момент времени автомат может менять значение каждого счётчика
не более чем на единицу, при этом значения счётчиков всегда должны остаться неотрицательным.
Ограничение \ref{eq:constraint} обеспечивает неотрицательность счётчиков.

Рассмотрим автомат с двумя счётчиками.

\begin{definition}
  \label{def:manoeuvre}
  Пусть у нас есть инициализированный автомат с двумя счётчиками.  Конечным манёвром называется
  поведение автомата от момента времени \(t_1\) до \(t_2\):
  \begin{align*}
    & (q(t_1), z_1(t_1), z_2(t_1)), \\
    & (q(t_1 + 1), z_1(t_1 + 1), z_2(t_1 + 1)), \\
    & \ldots, \\
    & (q(t_2), z_1(t_2), z_2(t_2))
  \end{align*}
  если выполняются следующие условия:
  \begin{align*}
    \begin{cases}
      \forall t (t_1 \leq t < t_2 \Rightarrow q(t) \notin Q_f) \\
      \forall t (t_1 < t < t_2 \Rightarrow (z_1(t) \ne 0 \wedge z_2(t) \ne 0) \\
      \begin{sqcases}
        z_1(t_1) = 0 \wedge z_2(t_1) \ne 0 \wedge z_2(t_2) = 0 \\
        z_2(t_1) = 0 \wedge z_1(t_1) \ne 0 \wedge z_1(t_2) = 0
      \end{sqcases}
    \end{cases}
  \end{align*}
\end{definition}

\begin{definition}
  \label{def:notfull_manoeuvre}
  Пусть у нас есть инициализированный автомат с двумя счётчиками.  Неполным манёвром называется
  поведение автомата от момента времени \(t_1\) до \(t_2\):
  \begin{align*}
    & (q(t_1), z_1(t_1), z_2(t_1)), \\
    & (q(t_1 + 1), z_1(t_1 + 1), z_2(t_1 + 1)), \\
    & \ldots, \\
    & (q(t_2), z_1(t_2), z_2(t_2))
  \end{align*}
  если выполняются следующие условия:
  \begin{equation*}
    \begin{cases}
      \forall t (t_1 \leq t < t_2 \Rightarrow q(t) \notin Q_f) \\
      \forall t (t_1 < t \leq t_2 \Rightarrow (z_1(t) \ne 0 \wedge z_2(t) \ne 0)) \\
      \begin{sqcases}
        z_1(t_1) = 0 \wedge z_2(t_1) \ne 0 \\
        z_2(t_1) = 0 \wedge z_1(t_1) \ne 0
      \end{sqcases} \\
      q(t_2) \in Q_f
    \end{cases}
  \end{equation*}
\end{definition}

\begin{definition}
  \label{def:infinity_manoeuvre}
  Пусть у нас есть инициализированный автомат с двумя счётчиками.  Бесконечным манёвром называется
  поведение автомата от момента времени \(t_1\):
  \begin{align*}
    & (q(t_1), z_1(t_1), z_2(t_1)), \\
    & (q(t_1 + 1), z_1(t_1 + 1), z_2(t_1 + 1)), \\
    & \ldots
  \end{align*}
  если выполняются следующие условия:
  \begin{equation*}
    \begin{cases}
      \forall t (t_1 \leq t \Rightarrow q(t) \notin Q_f) \\
      \begin{sqcases}
        z_1(t_1) = 0 \wedge \forall t (t_1 \leq t \Rightarrow z_2(t) \ne 0) \\
        z_2(t_1) = 0 \wedge \forall t (t_1 \leq t \Rightarrow z_1(t) \ne 0)
      \end{sqcases}
    \end{cases}
  \end{equation*}
\end{definition}

Мы рассмотрим вычислимость частично определенных функций от \(m\) переменных, то есть функций,
которые имеет вид: \(f: M \rightarrow \N_0\), где \(M \subseteq \N_0^m\).  Будем
записывать \(f(x_1, \ldots, x_m) = \lambda\), если \(f\) в точке \((x_1, \ldots, x_m)\) неопределена.

\begin{definition}
  \label{def:computability}
  Будем говорить что автомат \(\A\) с \(n\) счётчиками вычисляет функцию \(m\)-переменных
  
  \(f_{\A}: M \rightarrow \N_0\) (где \(M \subseteq \N_0^m\) и \(m \leq n\)), если:
  \begin{itemize}
  \item \(f_{\A}(x_1, x_2, \ldots, x_m) = y\) и инициализированный автомат
    \((\A, x_1, x_2, \ldots, x_m, 0, \ldots, 0)\) остановится, причем в момент остановки \(t'\)
    значение одного счётчика равно \(y\), а всех остальных равно \(0\)
  \item \(f_{\A}(x_1, x_2, \ldots, x_m) = \lambda\) и инициализированный автомат с \(n\) счётчиками
    \((\A, x_1, x_2, \ldots, x_m, 0, \ldots, 0)\) остановится, причем в момент остановки \(t'\)
    существует более чем один ненулевой счётчик.
  \item \(f_{\A}(x_1, x_2, \ldots, x_m) = \lambda\) и инициализированный автомат с \(n\) счётчиками
    \((\A, x_1, x_2, \ldots, x_m, 0, \ldots, 0)\) не остановится
  \end{itemize}
\end{definition}

Мы рассмотрим только частично определенных функций от одной переменной.  Обозначим через \(J_n\)
множество всех частично определенных функций одной переменной, которые вычислимы через автоматы с
\(n\) счётчиками.  Очевидно, что для любого \(n\) верно \(J_n \subseteq J_{n + 1}\).

Обозначим через \(\F\) все частично определенных функций от одной переменной.

Множество значений функции \(f \in \F\) обозначим через \(Im(f)\).

\begin{definition}
  \label{def:switcher}
  Пусть \(g \in \F\).  \(g\) называется переключательной функцией, если
  \(\left|Im(g)\right| < \infty\).
\end{definition}

Обозначим через \(\G\) множество всех переключательных функции.

\begin{definition}
  \label{def:switcher_rang}
  Пусть \(g \in \G\).  \(\left|Im(g)\right|\) называется рангом функции \(g\).
\end{definition}

\begin{definition}
  \label{def:function_with_switcher}
  Пара \((f, g)\) называется функцией с переключателем, если \({f \in \F, g \in \G}\) и
  
  \(\forall x [f(x) = \lambda \Leftrightarrow g(x) = \lambda]\).
\end{definition}

\begin{definition}
  \label{def:generalized_superposition}
  Пусть \((f_0, g_0)\), \((f_1, g_1)\), \((f_2, g_2)\), \ldots,
  \((f_n, g_n)\) --- функции с переключателями и
  \(Im(g_0) = \{k_1, k_2, \ldots, k_n\}\).
  \(S_n[(f_0, g_0), (f_1, g_1), (f_2, g_2), \ldots (f_n, g_n)]\) -- это пара функций \((f, g)\),
  где \(f\) и \(g\) имеют вид:
  \begin{align}
    \label{eq:generalized_superposition}
    & f(x) =
      \begin{cases}
        f_1(f_0(x)), & g_0(x) = k_1 \\
        f_2(f_0(x)), & g_0(x) = k_2 \\
        \ldots \\
        f_n(f_0(x)), & g_0(x) = k_n
      \end{cases} \\
    & g(x) =
      \begin{cases}
        g_1(f_0(x)), & g_0(x) = k_1 \\
        g_2(f_0(x)), & g_0(x) = k_2 \\
        \ldots \\
        g_n(f_0(x)), & g_0(x) = k_n
      \end{cases}
  \end{align}
  При этом для любого \(x \in \N_0\) если \(f_0(x) = \lambda\) (соответственно
  \(g_0(x) = \lambda\)), то \(f(x) = \lambda\) и \(g(x) = \lambda\)

  Операция \(S_n\) называется операцией обобщенной суперпозиции
\end{definition}

Логика операции обобщенной суперпозиции похоже на логику операции композиции над автоматами,
которая определена в работе \cite{litautomatapersecution} (в стр. 9).

Прежде чем определять следующий оператор введем некоторые обозначения:
\begin{itemize}
\item \(f^k(x)\) --- это \(k\) раз применения функция \(f\) на \(x \in \N_0\).  Если для \(x\)
  существует \(l \in \overline{1, k}\), такая что \(f^l(x) = \lambda\), то \(f^k(x) = \lambda\).
\item Пусть \((f, g)\) --- функция с переключателем.  Тогда для любого \(a \in \N_0\)
  определим следующие множества:
  \begin{align*}
    & \Delta_0(a) = \{x \in \N_0 | g(x) = a\} \\
    & \Delta_{k + 1}(a) = \{x \in \Delta_{k} | g(f^{k + 1}(x)) = a\},\ \text{где}\ k \geq 0 \\
    & X_0(a) = \N_0 \setminus \Delta_0(a) \\
    & X_{k + 1}(a) = \Delta_{k}(a) \setminus \Delta_{k + 1}(a),\ \text{где}\ k \geq 0 \\
    & X_{\infty}(a) = \N_0 \setminus \bigcup_{k \geq 0} X_k(a)
  \end{align*}
\end{itemize}

\begin{definition}
  \label{def:special_recursion}
  Пусть \(f_0, g_0 \in \F \times \G\) и \(a \in \N_0\).
  \(R_a[(f_0, g_0)]\) -- это пара функций \((f, g)\),
  где \(f\) и \(g\) имеют вид:
  \begin{align}
    \label{eq:generalized_superposition}
    & f(x) =
      \begin{cases}
        f^{k + 1}_0(x), & x \in X_k(a) \\
        \lambda, & x \in X_{\infty}(a)
      \end{cases} \\
    & g(x) =
      \begin{cases}
        g_0(x), & x \in X_0(a) \\
        g_0(f_0^k(x)), & x \in X_k(a), k \geq 1 \\
        \lambda, & x \in X_{\infty}(a)
      \end{cases}
  \end{align}
  При этом для любого \(x \in \N_0\) если \(f_0^l(x) = \lambda\) (где \(1 \leq l \leq k\)), то
  \(f(x) = \lambda\) и \(g(x) = \lambda\)

  Операция \(R_a\) называется операцией специальной рекурсии
\end{definition}

\begin{definition}
  \label{def:periodic}
  Функция \(f \in \F\) называется периодичной, если существуют \(T \in \N\) и \(x_0 \in \N_0\),
  такие что для любого \(x > x_0\) и для любого \(k \in \N_0\) верно \(f(x) = f(x + kT)\).
\end{definition}

Аналогично определяется периодичная функция с целочисленными значениями.

Обозначим наименьший период функции \(g\) через \(T_{g}\).

Обозначим множество всех периодичных функции через \(\G_p\).  Очевидно, что
\(\G_p \subset \G\).

\begin{definition}
  \label{def:pseudoperiodic}
  Функция \(f \in \F\) называется псевдопериодичной, если существует \(x_0 \in \N_0\), такое что для
  любого \(x > x_0\) существует \(T \in \N\), такое что для любого \(k \in \N_0\) верно
  \(f(x) = f(x + kT)\).
\end{definition}

Аналогично определяется псевдопериодичная функция с целочисленными значениями.

Обозначим множество всех псевдоперидочных функции через \(\F_p\).  Очевидно, что
\(\G_p \subset \F_p\).

\begin{definition}
  \label{def:manoeuvre_function}
  Функция \(f \in \F\) называется функцией манёвра, если она имеет один из следующих видов:
  \begin{align}
    \label{eq:manoeuvre_function}
    & f(x) =
      \begin{cases}
        C_0, & x = 0 \\
        C_1, & x = 1 \\
        \ldots \\
        C_k, & x = k \\
        \frac{a x + b(x)}{d}, & x > k
      \end{cases} \\
    \label{eq:manoeuvre_function_nd}
    & f(x) =
      \begin{cases}
        C_0, & x = 0 \\
        C_1, & x = 1 \\
        \ldots \\
        C_k, & x = k \\
        \lambda, & x > k
      \end{cases}
  \end{align}
  где \(C_0, C_1, \ldots C_k \in \N_0 \cup \{\lambda\}\), \(b(x)\) --- периодичная функция с
  целочисленными значениями, которая имеет предпериод \(k\) и период \(d\).
  Причем \(b(x)\) такая, что \(\frac{a x + b(x)}{d} \in \N_0\)
  для всех \(x \in \N_0\).  Число \(d\) называется шагом функции
  манёвра и обознается через \(d_{f}\).  А число \(k\) называется предманёвр функции манёвра и
  обозначается через \(k_f\).
\end{definition}

Обозначим множество всех функций манёвра через \(\F'\).

\begin{definition}
  \label{def:manoeuvre_function_switcher}
  Функция с переключателем \((f, g)\) называем функция манёвра с переключателем, если
  выполняются следующие условия: \(f \in \F'\), \(g \in \G_p\) \(d_f = T_{g}\) и предманёвр
  \(f\) совпадает предпериодом \(g\).
\end{definition}

Обозначим множество всех функций манёвра с переключателем через \(\M'\).

\begin{definition}
  \label{def:generalized_manoeuvre_function_with_switcher}
  Определим обобщенную функцию маневра с переключателем через индуктивное определение:
  \begin{enumerate}
  \item Любая функция маневра с переключателем это обобщенная функция маневра с переключателем.
  \item Для любых \(n \in \N\) и \(m \in \N_0\) если \((f_0, g_0)\), \((f_1, g_1)\),
    \((f_2, g_2)\), \ldots, \((f_n, g_n)\) являются обобщенными функциями маневра с
    переключателем, то функции
    \((f', g') = S_n[(f_0, g_0), (f_1, g_1), \ldots, (f_n, g_n)]\) и
    \((f'', g'') = R_a[(f_0, g_0)]\) тоже являются обобщенными функциями маневра с
    переключателем.
  \end{enumerate}
\end{definition}

Обозначим множество всех обобщенных функций манёвра с переключателем через \(\M_2\).

\begin{definition}
  \label{def:generalized_manoeuvre_function}
  Функция \(f\) называется обобщенной функцией манёвра, если существует \({g \in \G}\) такая, что
  \((f, g) \in \M_2\).
\end{definition}

Обозначим множество всех обобщенных функции манёвра через \(\F_2\).

Определим еще одно понятие для доказательство основной теоремы.

\begin{definition}
  \label{def:graph}
  Пусть нам дано конечное ориентириванное дерево.
  Корень дерево обозначается через \(v_s\).
  И пусть выделено некоторое подмножество листьев этого дерева \(V_f\), которое называется
  множеством финальных вершин.
  Проводим такую операцию несколько раз над вершинами графа:
  \begin{enumerate}
    \item Выделим некоторую вершину \(v \in V \setminus V_f\)
    \item Рассмотрим простую цепь \(v_s, v_1, v_2, \ldots, v\). И выбираем некоторую вершину \(v_i\)
      (возможно саму \(v\))
    \item Проводим ребро, исходящее от \(v\) и заходящее в \(v_i\)
  \end{enumerate}
  В полученном графе пометим вершины меткой \((f, g)\), где \((f, g) \in \M \subseteq \F \times \G\).
  А ребра исходящие от \(v\) пометим значениями из множества \(Im(g)\), при этом мощность должен
  совпадать количеству исходящих ребер и у одной вершины не будет два ребра исходящие от неё,
  которые имеет одинаковые метки.
  И все ребра заходящие к одному вершину имеет одинаковые метки, а ребра заходящие разные вершины
  имеет разные метки.
  Полученный граф \(G\) называем вычислительный граф над множеством \(\M\).
\end{definition}

\begin{definition}
  \label{def:vertex_level}
  Пусть нам дано вычислительный граф \(G\) и пусть \(v\) его вершина. Тогда длина кратчайший цепи
  от корня до этой вершины будем называть уровнем вершины \(v\).
\end{definition}

\begin{definition}
  \label{def:graph_level}
  Пусть нам дано вычислительный граф \(G\). Максимальный уровень среди всех вершин графа будем
  будем называть уровень графа.
\end{definition}

Вычислительный граф \(G\) принимает как вход некоторое \(x \in \N_0\) и дает другое число используя
следующий алгоритм:
\begin{enumerate}
\item В качестве активной вершины берём корень, а в качестве текущего значения берём текущее
  значения.
\item Если \(v_a \in V_f\), алгоритм закончится и в качестве ответа даем текущее занчения,
  если нет переходим на шаг 3.
\item Пусть активная вершина -- \(v\), текущая значения -- \(y\), а метка активной вершины -- \((f_v, g_v)\).
  Находим \(v'\), такое что метка \((v, v')\) равно \(g_v(y)\).
  И находим \(y' = f_v(y)\).
  Тогда в качестве текущей значении берём \(y'\), а активную вершину \(v'\), и переходим на шаг 2.
\end{enumerate}

Если алгоритм при некотором входном значении \(x \in \N_0\) не закончится
или в каком-то шаге функция \(f_(x)\) даёт неопределённость,
то считаем что вычислительный граф \(G\) даёт неопределённость как ответ.

Последовательность вершин \(v_1, v_2, \ldots, v_n\), которые были активны называем путь вычисления
\(x\).

\begin{definition}
  \label{def:graph_function}
  Вычислительный граф \(G\) над множеством \(\M\) вычисляет функцию \(f_G\), если \(G\) при
  входном значении \(x\) даёт ответ равную \(f(x)\) и даёт неопределённость, если функция \(f(x)\),
  не определено.
\end{definition}

Определим некоторые операции над вычислительными графами.

\begin{definition}
  \label{def:unite}
  Пусть дано вычислительный граф \(G\) над множеством \(\M\) и его вершина
  \(v \in V \setminus V_f\).  Пусть из вершины \(v\) исходит ребра, которые заходить к вершинам
  \(v_1, v_2, \ldots, v_n\).
  и имеет метки \(k_1, k_2, \ldots, k_n\) соответственно. При этом
  к вершинам \(v_1, v_2, \ldots, v_n\) не заходить другие ребра (в том числе они не имеет петли).
  Тогда определим операцию объединение над вершиной \(v\) следующим образом:
  \begin{enumerate}
  \item Поменяем метку вершины \(v\) на
    \(S_n[(f_v, g_v), (f_1, g_1), (f_2, g_2), \ldots, (f_n, g_n)]\).
    Здесь \((f_i, g_i)\) равно:
    \begin{itemize}
    \item метку вершины \(v_i\), если \(v_i \in V \setminus V_f\) и если уровень вершины
      \(v_i\) строго больше, чем уровен вершины \(v\).
    \item \((I, Const_{k_i})\), если \(v_i \in V \setminus V_f\) и если уровень вершины
      \(v_i\) не больше, чем уровен вершины \(v\).
    \item \((I, Const_{k_i})\), если \(v_i \in V_f\).
    \end{itemize}
  \item Удалим ребра исходящие от \(v\) и заходящие к вершинам \(v_{i_1}, v_{i_2}, \ldots, v_{i_k}\),
    которые является вершинами уровнем больше чем \(v\).
  \item Проводим ребро с меткой \(a\) исходящий от \(v\) к вершине, которому заходить ребро с той
    же меткой исходящий от вершин \(v_{i_1}, v_{i_2}, \ldots, v_{i_k}\).
    Если получится несколько ребер у вершины \(v\), которые заходить на одно вершину
    \(v'\) уровнем не больше чем уровень \(v\) (такое может случится, например если два вершины из
    \(v_{i_1}, v_{i_2}, \ldots, v_{i_k}\) имеет ребра заходящие к \(v'\)), то
    объединаем их (это корректно, поскольку все вершины заходящие к \(v'\) имеет одинакувую метку).
  \item Удалим вершины \(v_{i_1}, v_{i_2}, \ldots, v_{i_n}\)
  \end{enumerate}
\end{definition}

\begin{definition}
  \label{def:eliminate_loop}
  Пусть дано вычислительный граф \(G\) над множеством \(\M\) и его вершина 
  \(v \in V \setminus V_f\).  Пусть вершина \(v\) имеет петлю по метке \(a\). Тогда операцию
  устранения петли определим над вершиной \(v\) так:
  \begin{enumerate}
  \item Меняем метку вершины \(v\) на \(R_a[(f_v, g_v)]\)
  \item Удалим петлю с меткой \(a\)
  \end{enumerate}
\end{definition}

\clearpage

\section{Классические результаты}

%\begin{theorem}
  %\label{theor:one_counter}
  %\(J_1\) состоит из периодических функции и функции следующего вида:
  %\begin{equation*}
    %f(x) =
    %\begin{cases}
      %C_0, & x = 0 \\
      %C_1, & x = 1 \\
      %\ldots \\
      %C_k, & x = k \\
      %x + c, & x > k
    %\end{cases}
  %\end{equation*}
  %где \(C_0, C_1, \ldots, C_k \in \N_0 \cup \{\lambda\}\) и \(k, c \in \N_0\).
%\end{theorem}

\begin{theorem}
  \label{theor:three_counter}
  \(J_3\) совпадает с классом частично рекурсивных функций от одной переменной.
\end{theorem}

\begin{theorem}
  \label{theor:two_counter_special}
  Пусть у нас есть кодировка \(x \mapsto 2^x\).  В такой кодировке любая частично рекурсивная
  функция вычислима через автоматы с двумя счётчиками.
\end{theorem}

\clearpage

\section{Основные результаты}

\begin{theorem}
  \label{computable_functions}
  \(J_2 = \F_2\).
\end{theorem}

\begin{hypothesis}
  Любая функция из \(J_2\) имеет вид:
  \begin{equation}
    \label{eq:pseudoperiodic}
    f(x) = \frac{a(x) \cdot x + b(x)}{d(x)}
  \end{equation}
  где \(a(x), b(x), d(x)\) являются псевдопериодичными функциями.
\end{hypothesis}

\clearpage

\section{Леммы и доказательства}

\begin{lemma}
  \label{lemma:manoeuvre}
  Пусть дано автомат с 2 счётчиками \(\A\) с \(N\) состояниями.
  Нумеруем все состояния автомата:
  \(q_0, q_1, q_2, \ldots, q_{N - 1}\).
  И пусть \(q(t_1) = q_{l_1}\).
  Тогда существуе функция манёвра с переключателем
  \((f, g) \in \M'\), для которого верно:
  \begin{enumerate}
  \item Если автомат \(\A\) совершает конечный манёвр, начиная с
    момента времени \(t_1\) до момента времени \(t_2\), тогда:
    \begin{equation*}
        \begin{sqcases}
          \begin{cases}
            z_2(t_1) = 0 \\
            z_2(t_2) = f(z_1(t_1)) \\
            q(t_2) = q_{l_2} \Rightarrow g(z_1(t_1)) = 2 * l_2 + 1
          \end{cases} \\
          \\
          \begin{cases}
            z_1(t_1) = 0 \\
            z_1(t_2) = f(z_2(t_1)) \\
            q(t_2) = q_{l_2} \Rightarrow g(z_2(t_1)) = 2 * l_2
          \end{cases}
        \end{sqcases}
    \end{equation*}
  \item Если автомат \(\A\) совершает неполный манёвр, начиная с
    момента времени \(t_1\) до момента времени \(t_2\), тогда:
    \begin{equation*}
        \begin{sqcases}
          \begin{cases}
            z_2(t_1) = 0 \\
            f(z_1(t_1)) = \lambda \\
            g(z_1(t_1)) = \lambda
          \end{cases} \\
          \\
          \begin{cases}
            z_1(t_1) = 0 \\
            f(z_2(t_1)) = \lambda \\
            g(z_2(t_1)) = \lambda
          \end{cases}
        \end{sqcases}
    \end{equation*}
  \item Если автомат \(\A\) совершает бесконечный манёвр, начиная с
    момента времени \(t_1\), тогда:
    \begin{equation*}
        \begin{sqcases}
          \begin{cases}
            z_2(t_1) = 0 \\
            f(z_1(t_1)) = \lambda \\
            g(z_1(t_1)) = \lambda
          \end{cases} \\
          \\
          \begin{cases}
            z_1(t_1) = 0 \\
            f(z_2(t_1)) = \lambda \\
            g(z_2(t_1)) = \lambda
          \end{cases}
        \end{sqcases}
    \end{equation*}
  \end{enumerate}
\end{lemma}

В этом слуае говорится что состояния \(q_{l_1}\) реализует функцию с переключателем \((f, g)\).

\begin{proof}
  Мы будем доказывать только случай когда \(z_2(t_1) = 0\), так как случай
  \(z_1(t_1) = 0\) доказывается аналогично.

  Заметим, что нам достаточно доказать утверждения начиная с некоторого \(k\),
  так как в выражениях \ref{eq:manoeuvre_function}
  и \ref{eq:manoeuvre_function_nd} значения констант \(C_0, C_1,
  \ldots, C_k\) можно задать любым способом,
  и в предпериоде функция \(g\) тоже может принимать любые значения.

  \begin{enumerate}
  \item Пусть автомат совершает конечный манёвр, начиная с момента \(t_1\) и заканчивая в моменте
    \(t_2\).
    Рассмотрим два случая:
    \begin{itemize}
    \item Для любого \(x\) и для любого \(t\)
      (где \(t_1 \leq t \leq t_2\)) верно, что:
      \begin{equation*}
        (z_1(t_1) = x \wedge z_2(t_1) = 0) \Rightarrow z_2(t) \leq N
      \end{equation*}

      Пусть \(x > N (N + 1) + 1\). Тогда \(t_2 - t_1 \geq N (N + 1) + 1\).
      Заметим, что \(z_2(t)\) может принимать \(N + 1\) различных значений,
      а \(q(t)\) может принимать \(N\) различных значений.
      Тогда существует моменты времени \(i\) и \(j\), для которых верно:
      \begin{equation*}
        \begin{cases}
          t_1 \leq i < j < t_2 \\
          q(i) = q(j) \\
          z_2(i) = z_2(j) \\
          z_1(i) > 0 \wedge z_1(j) > 0
        \end{cases}
      \end{equation*}
    \end{itemize}
  \end{enumerate}
\end{proof}

По лемме \ref{lemma:manoeuvre} каждому состоянию автомата \(\A\) можно сопоставить
две функции манёвра с переключателем, зависимости от значения какого счётчик равно 0.

\begin{lemma}
  \label{lemma:automata_to_graph}
  Пусть дано автомат \(\A\) c 2 счётчиками, и пусть это автомат вычисляет функция
  \(f_{\A} \in \F\).  Тогда существует вычислительный граф над множеством
  \(\M'\), который вычисляет ту же функцию \(f_{\A}\).
\end{lemma}

\begin{proof}
  Пусть автомат \(\A\) имеет \(N\) состоянии.
  Для каждого не финального состояния \(q_l\), построим две функции манёвра с переключателем \((f_{2l}, g_{2l}),
  (f_{2 l + 1}, g_{2 l + 1})\) по лемме \ref{lemma:manoeuvre}. Построим граф \(G\) из пустого графа по уровням вершин
  (обозначим через \(i\) текущий уровень):
  \begin{enumerate}
  \item \(i = 0\) (по определению существует только одна вершина, которая имеет уровен \(0\)).
    Если верно \(q_0 \in Q_f\), то сразу остановимся.
    Добавим вершину обозначаемую через \(v_0\), и пометим эту вершину функцией \((f_0, g_0)\).
    Добавим \(|Im(g_0) \ \{0\}|\), вершин и проводим ребра от \(v_0\) с метками из \(Im(g_0) \ \{0\}\).
    Если \(0 \in Im(g_0)\), тогда проводим петлю с меткой \(0\).
  \item \(i > 0\). Пусть построено \(i\) уровень.
    Для каждой нефинальной вершины \(i + 1\)-уровня сделаем следующую действию.
    Пусть \(v\) --- вершина с уровнем \(i + 1\). Тогда рассмотрим ребро заходящий к \(v\) имеет
    метку \(l\), тогда переобозначим вершину через \(v_l\) и пометим эту вершину через \((f_l, g_l)\).
    Если для этой состоянии не определно \((f_l, g_l)\), что означаеть соответствующая вершина
    финальная, то пометим вершину \(v_l\) как финальную.
    Пусть \(v_0, v_{j_1}, v_{j_2}, \ldots, v_l\) является кратчайшей простой цепью от \(v_0\) до \(v_l\)
    и пусть \(k \in Im(g)\).
    \begin{itemize}
    \item Если в графе существует вершина \(v_k\) и она находится в выше указанном цепи,
      то проводим ребро с меткой \(k\) к вершину \(v_k\).
    \item Если \(v_k\) не находится в выше указанном цепи,
      то добавим вершину и проводим ребро с меткой \(k\) к этому вершину.
    \end{itemize}
  \item Если в течении шага 2 добавили только финальные вершины и ребра уже существующим вершинам,
    то закончим алгоритм, если нет то в качестве \(i\) берём \(i + 1\) и повторяем шаг 2
  \end{enumerate}

  Докажем что алгоритм конечный. Это следует из-за того что каждый кратчайший простой цепь не длиннее
  чем \(2  N\) (потому что у нас \(N\) состоянии у автомата, от этого следует число разных вершин
  максимум \(2 N\)). От этого следует конечность алгоритма.

  Теперь докажем что они вычисляет одинаковые функции. Пусть \(x\) дано как значения первого счётчика
  и как входное значения графа \(G\).
  Докажем что для любого \(n\),
  значения счётчика в начале \(n\)-манёвра совпадает с текущем значениям в \(n\)-шаге графа, и
  функция с переключателем который соответствует текущему состояния автомата и значении нулевых
  счётчиков совпадает с меткой активной вершины.
  Докажем через индукцию:
  \begin{enumerate}
  \item База индукции. \(n = 0\). Входное значения равно начальному значения счётчика (это по условии).
    А функция соответствующий к \(q_0, z_2(0) = 0\), по построению графа как раз таки совпадает с
    меткой корня.
  \item Шаг индукции. Пусть утверждения доказано для \(n = k\), тогда докажем это утверждения для
    \(n = k + 1\). Если утверждения верно для \(n = k\), то это означает что означает значения
    одного счётчика совпадает с текущем значениям для шага \(k\). Тогда значения в шаге \(n = k + 1\),
    тоже совпадает, поскольку мы в шаге \(k\) вычисляем одинаковые функции. Текущие функции совпадает
    в силу построения
  \end{enumerate}
\end{proof}

\begin{lemma}
  \label{lemma:manoeuvre_function}
  Пусть дано функция манёвра с переключателем \((f, g)\).
  Тогда существует автомат с 2 счётчиками \(\A\) c \(N\) сотояниями \(q_0, q_1, \ldots, q_{N - 1}\)
  и существует состояния этого автомата \(q_{l_1}\) для которых верно:
  \begin{itemize}
  \item Для любого \(x \in \N_0\), если \(f(x) = \lambda, g(x) = \lambda\),
    то автомат \(\A\) при состоянии \(q'\) и при значении счётчиков \(z_1(t_1) = x, z_2(t_2 ) = 0\)
    совершает либо бесконечный манёвр, либо неполный манёвр.
  \item Если \(f(x) = y, g(x) = l_2\) то автомат \(\A\) совершает 2 конечных манёвра и
    в конце 2 манёвра будет:
    \(q(t) = q_{l_2}, z_1(t) = y, z_2(t) = 0\).
  \end{itemize}
\end{lemma}

То есть в этой лемме будет построен автомат который реализует функцию через 3 конечных манёвра,
но в конце 2-счётчик всегда будет равно 0.

\begin{proof}
  Для каждого значения \(g(x)\) добавим соответствуюшую состоянию.
  Пусть предманёвр \(f\) и предпериод \(g\) равно \(k\), и \(С_0, C_1, \ldots C_k\) и \(i_0,
  i_1, \ldots, i_k\) первые значения функции \(f\), \(g\) соответственно.
  Предманёвр моделируется так:
  \begin{enumerate}
  \item Первый манёвр.
    \begin{itemize}
    \item Случай когда \(x = 0\). Автомат первый шаг автомата будет увеличить оба счётчика.
      Потом не меняя первый счётчик, сделаем так, чтобы значения первого счётчика было равно \(C_0\).
      Потом уменьшаем значения первого счётчика.
      Автомат закончить манёвр на состоянии \(q'_{g(x)}\)

    \item Случай когда \(0 < x \leq k\). Тогда сначала автомат сделает значения второго счётчика
      \(C_1\). И потом уменшает первый счётчик. Если \(x = 1\), то тогда манёвр закончится и значения
      второго счётчика будет \(C_1\). Если \(x > 1\), то теперь сделает значения 2-счётчика \(C_2\) и
      уменьшает счётчик 1. И так далее до \(k\).
      Если после \(k\) уменьшение первого счётчика значение не будет \(0\) (это означает \(x > k\)),
      то возвращается к значениям счётчика \(z_1(t) = x, z_2(t) = 1\) (\(z_2(t) = 1\) чтобы не закончит
      манёвр). Здесь тоже когда уменьшаем значения 2-счётчика, нужно переходить на состояния
      \(q'_{g(x)}\).

    \item Случай когда \(x > k\) и когда автомат уже возвращаелся к \(z_1(t) = x, z_2(t) = 1\).
      Если значения для \(x > k\) неопределено то просто автомат остановится и удовлетворим условию леммы.

      Теперь случай когда это не так.
      Тогда \(f(x) = \frac{a x + b(x)}{d}\)
      Автомат \(\A\) начинает совершать периодическое спуск. Настроим автомат таким образом:
      За один период автомат уменьшает значения
      первого счётчика на \(q\), а значения второго счётчика увеличивает на \(p\).
      При этом как он будет проходить этот период зависить от функции \(b(x)\).
      Зависимости от значения этой функции, автомат каждый перед уменьшением 1-счётчика, изменить
      второй счётчик нужным образом. Автомат закончить манёвр на состоянии \(q'_{g(x)}\)
    \end{itemize}

  \item Второй манёвр.
    В ходе второго манерва каждом шаге уменьшим 2-счётчик, и увеличиваем 1-счётчик в каждом шаге
    и остаемся в состоянии \(q'_{g(x)}\). Тогда в конце этого манёвра будет \(q(t) = q'_{g(x)},
    z_1(t) = f(x), z_2(t) = 0\)

  \item Третий манёвр.
    Не изменяя значения счётчиков переводим состояния от \(q'_{g(x)}\) на \(q_{g(x)}\).
  \end{enumerate}

  Тогда в конце получим \(q(t) = q_{g(x)}, z_1(t) = f(x), z_2(t) = 0\).
\end{proof}

\begin{lemma}
  \label{lemma:graph_to_automata}
  Пусть дано вычислительный граф \(G\) над множеством \(\M'\) и пусть это граф вычисляет функция
  \(f_G : \F\).  Тогда существует автомат с двумя счётчиками, который
  вычисляет ту же функцию \(f_G\).
\end{lemma}

\begin{proof}
  Пусть вычислительный граф состоит из не финальных вершин \(\{v_0, v_1, \ldots, v_n\}\) и
  множество финальных вершин \(\{v'_0, v'_1, \ldots, v'_m\}\). Тогда для каждой не финальный вершины
  будем составить программу автомата \(\A_i\) по лемме \ref{lemma:manoeuvre_function}, где \(0 \leq i \leq n\).
  И просто объединаем все программы и начальной состоянии автомата будет состояния, которая
  соответствует к корню.
  Полученное автомат будет вычислять ту же функцию \(f_G\). Это выходить из построения автомата \(\A\)
  и доказывается по индукции как в лемме \ref{lemma:automata_to_graph}
\end{proof}

\begin{lemma}
  \label{lemma:unite_closure}
  Пусть дано вычислительный граф \(G\) над множеством \(\M \subseteq \F \times \G\),
  который вычисляет функцию \(f_G: \F\) и пусть \(v \in V \setminus V_f\).  Тогда
  граф \(G^*\), полученное применением операции объединение над \(v\) тоже является
  вычислительным графом и тоже вычисляет функцию \(f_G\).
\end{lemma}

\begin{proof}
  Вершины в графе \(G\), удаленные в результате операции обозначим через \(v_1, v_2, \ldots, v_n\).
  Докажем что граф \(G^*\) остается связным, потому что если в графе \(G\) от вершины \(v_i\) исходить
  ребро с меткой \(а\) в вершину \(v'\), то в графе \(G^*\), ребро такой же меткой и заходящее в
  \(v'\) исходить от вершины \(v\). То есть для всех вершин, для которых существовал путь от корня
  к этим вершинам проходящий через вершины \(v\) и \(v_i\) в графе \(G\),
  тоже существует путь от корня до этих вершин в графе \(G^*\). От этого следует что \(G^*\) остается
  связным.

  Еще в графе \(G^*\) не возникает ситуации когда одну вершину \(v'\) заходить два ребра
  исходяшие от вершин более низкого уровня, поскольку в графе \(G\) это было не так, а в ходе
  операции мы только можем заменят одно ребро заходящий к вершину \(v'\) с одним ребром заходящую к
  вершину \(v'\), но возможно исходящую от другой вершины. От этого следует что если не рассмотреть
  ребро исходящий от вершины уровня \(i\) и заходящий к вершину \(j \leq i\), то получиться
  ориентированное дерево. То есть граф \(G^*\) является вычислительным графом.

  Осталось доказать что граф \(G^*\) вычисляет ту же функцию, что и \(G\).
  Если путь вычисления числа \(x\) не проходить через \(v\) в графах \(G\) и \(G'\), то они
  даёт одинаковый ответ. Если путь вычисления \(x\) в графе \(G\) проходить через \(v\), но
  следующая вершина в пути либо финальная вершина, либо вершина уровня не больше уровня \(v\).
  Но тогда по определению операции объединение в этом случае тоже ничего не меняется.
  И наконец, пусть путь вычисления \(x\) в графе \(G\) проходить через \(v\) и \(v_i\).
  И пусть \((f, g)\) и \((f_i, g_i)\) метки вершины \(v\) и \(v_i\), а метка ребра исходящий
  от \(v\) и заходящий в вершину \(v_i\) является \(k_i\).
  Тогда эти два вершины вычисляет функцию \(f_i(f(y))\), где \(y\) текущая значения на вершине
  \(v\) и определяет какая вершина будет следующая через \(g_i(f(y))\). Но по определению
  операции объединение если в вершине \(g(y)\) равно \(k_i\), то вычисляется функция \(f_i(f(y))\)
  и следующая вершина определяется через \(g_i(f(y))\). А это означает граф \(G\) и \(G^*\)
  даёт одинаковый ответ в этом слуае тоже.
\end{proof}

\begin{lemma}
  \label{lemma:eliminate_loop_closure}
  Пусть дано вычислительный граф \(G\) над множеством \(\M \subseteq \F \times \G\),
  который вычисляет функцию \(f_G: \F\) и пусть \(v \in V \setminus V_f\).  Тогда
  граф \(G^*\), полученное применением операции устранения петли над \(v\) тоже является
  вычислительным графом и тоже вычисляет функцию \(f_G\).
\end{lemma}

\begin{proof}
  Мы применяя эту операцию просто удалили одну петлю. Соответственно \(G^*\) --- вычислительный граф
  над множеством \(\M'\) (возможно отличный от \(\M\)). Докажем, что вычислимая функция
  \(f_G\) остался таким же. Рассмотрим любую \(x\), путь вычисления которого содержить \(v\) и
  проходить через ребро с меткой \(a\) (которая была меткой петли). Других случаях пути вычисления
  \(x\) совпадает для \(G\) и \(G^*\).

  Тогда пусть в \(G\), путь вычисления \(x\) проходить \(k\) раз подряд. Это означает для любого
  \(i < k\), \(g(f^i(x)) = a\). Соответственно в графе \(G\), после прохождения \(v\) вычисляется
  функция \(f^{k + 1}(x)\) и \(g(f^k(x))\).

  Теперь рассмотрим путь вычисления в графе \(G^*\). Поскольку \(x\) такое число что
  \(g(f^k(x)) \ne a\), но для любого \(i < k\), \(g(f^i(x)) = a\)
  то по определению оператора \(R_a\), вычисляется как раз таки функции \(f^{k + 1}(x)\) и
  \(g(f^k(x))\).
\end{proof}

\begin{lemma}
  \label{lemma:graph_to_function}
  Пусть дано вычислительный граф \(G\) над множеством \(\M'\). Тогда функция \(f_G\)
  которая вычисляет граф является обобщенная функция манёвра, то есть \(f_G \in \F_2\)
\end{lemma}

\begin{proof}
  Производим следующие действия над графом \(G\):
  \begin{enumerate}
  \item \(i\) уровень вершин, Которые мы рассмотрим. В начале \(i\) равно уровень графа.
  \item Рассмотрим все вершины уровня \(i\). Если все вершины уровня \(i\) является финальными
    вершинами, то в качестве новой значении \(i\) берём \(i - 1\) и переходим на 2 шаг.
  \item Если какой-то вершина \(v\) уровня \(i\) имеет петю, то применяем к
    этой вершине операцию устранения петли.
  \item Дальше рассмотрим вершину \(v\) уровня \(i - 1\) и для каждой из них применяем операцию объединение.
    Вершине \(v\) можно применять операцию объединение, поскольку все вершины \(i\) имеет полустепень
    захода \(1\). Это следует из построение вычислительного графа и от того что вершины степены \(i\)
    не имеет петли, поскольку мы эти петли устранили предедущем шаге.
    Если \(i - 1 = 0\),  то закончим алгоритм. Если нет то уменьшаем значения \(i\) и повторяем 2 шаг.
  \end{enumerate}

  Алгоритм конечный, поскольку каждом цикле мы убираем все не финальные вершины одного уровня,
  и как следствия количество не финальных вершин всегда уменьшается.

  В конце остается только корень \(v_0\) и если метка этой вершины \((f, g)\), то функция \(f_G\),
  которая вычислима в вычисительной графе \(G\) равно \(f\). Это следует от леммы
  \ref{lemma:unite_closure} и \ref{lemma:eliminate_loop_closure}.
\end{proof}

\begin{lemma}
  \label{lemma:function_to_graph}
  Пусть дано обобщенная функция манёвра с переключателем \((f, g)\) и
  пусть 
  \(Im(g) = {k_1, k_2, \ldots, k_n}\).
  Тогда можно построить вычислительный граф \(G\), финальных вершин которых является
  \(\{v_{k_1}, v_{k_2}, \ldots, v_{k_n}\}\) и для которого верно:
  \begin{itemize}
  \item Вычислительный граф вычисляет функцию \(f\)
  \item Если \(g(x) = k_i\), то вычисления закончиться в финальной вершине \(v_{k_i}\)
  \end{itemize}
\end{lemma}

\begin{proof}
  Докажем по индукции по построению функции:
  \begin{enumerate}
  \item Базис индукции. Пусть функция \((f, g) \in \M'\). Тогда можно постороить вычислительный граф
    с единственным нефинальной вершиной c пометкой \((f, g)\) и соответствующими \(Im(g)\)
    финальными вершинами.
  \item Шаг индукции. Пусть существует графы \(G_0, G_1, \ldots G_n\) который вычисляет
    функцию \((f_0, g_0), (f_1, g_1), \ldots, (f_n, g_n) \in \M_2\).
    \begin{enumerate}
    \item Докажем что существует граф вычисляющий \(S_n[(f_0, g_0), (f_1, g_1), \ldots (f_n, g_n)]\).
      Построим это граф таким образом: удалим финальную вершину \(v_{i_k}\) который
      соответствует значению \(k_i\) из \(Im(g_0)\), вместо этой вершины подставим граф \(G_i\)
      (то есть граф который соответствует функцию \((f_i, g_i)\), которая вычисляется при \(g_0(x) = k_i\)).
      Это процедуру повторим для всех вершин и очевидно что полученный граф \(G'\) удовлетворяет
      условию \(S_n[(f_0, g_0), (f_1, g_1), \ldots (f_n, g_n)]\)
    \item Докажем что существует граф вычисляющий \(R_a[f_0, g_0]\).
      Если \(a \notin Im(g_0)\), то в качестве ответа можем брать исходный граф \(G_0\).
      Если \(a \in Im(g_0)\), то берём граф \(G_0\), удалим от фтинальную вершину соответствующий
      к \(a\) и проводим заходящую к этой вершины ребро проводим в корень. По определению оператора
      \(R_a\) и по построению нового графа полученный граф удовлетворяет условия для \(R_a[f_0, g_0]\)
    \end{enumerate}
  \end{enumerate}
\end{proof}

\begin{theorem}
  \label{computable_functions}
  \(J_2 = \F_2\).
\end{theorem}

\begin{proof}
  По лемме \ref{lemma:automata_to_graph} и \ref{lemma:graph_to_function} можно утверждать
  что \(\F_2 \subseteq J_2\).
  По лемме \ref{lemma:function_to_graph} и \ref{lemma:graph_to_automata} можно утверждать
  что \(J_2 \subseteq \F_2\).
  От этого выходить что \(\F_2 = J_2\)
\end{proof}

\clearpage

\section{Заключение}

В результате данной работы было получено способ задания функции вычислимые через автомат с двумя
счётчками через специальных класс парных функции и специальных операции над ними. Возможно можно
построить более общий вид этих операции, который будет применими не только автоматам с двумя
счётчиками но и другим автоматным устройствам.

Если приведенная гипотеза о виде функции вычислимые через автоматы с двумя счётчиками будет
доказано, это позволяеть утверждать функции растущие быстрее чем линейные функции (например
\(x^2, 2^x\)) и функции растущие медленнее чем линейные функции \(\lfloor \log_2 x \rfloor,
\lfloor \sqrt(x) \rfloor\) не вычислимые через автоматы с двумя счётчиками.

Автор выражает благодарность научному руководителю Н.Ю. Волкову за постановку задачи, за помощь и
за ценные советы в ходе написании курсовой.

\clearpage

\begin{thebibliography}{}
\bibitem{litautomatacounters} Кузьмин Е.В., Соколов В.А.  \textit{Автоматные счетчиковые
    машины}. Ярославль, 2012.
\bibitem{litautomatatheory} Кудрявцев В.Б., Алешин С.В., Подколзин А.С.  \textit{Введение в теорию
    автоматов}. Наука, 1985.
\bibitem{litautomatalanguages} Д. Хопкрофт, Р. Мотвани, Д. Ульман. \textit{Введение в теорию
    автоматов, языков и вычислений}. 2-е изд. : Пер. с англ. --- Москва, Издательский дом
  ``Вильямс'', 2002.
\bibitem{litautomatapersecution} Н. Ю. Волков. \textit{Об автоматной модели преследования}.
    Дискретная математика, 2007
\bibitem{litautomatainquadrant} Ю. Л. Хегай. \textit{Поведение в квадранте неприодических автоматов}.
    Выпускная квалификационная работа, 2020.
\end{thebibliography}

\end{document}